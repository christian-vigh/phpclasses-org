<?php
/**************************************************************************************************************

    NAME
	PdfToText.phpclass

    DESCRIPTION
    	A class for extracting text from Pdf files.
	Usage is very simple : just instantiate a PdfToText object, specifying an input filename, then use the
	Text property to retrieve PDF textual contents :

		$pdf	=  new PdfToText ( 'sample.pdf' ) ;
		echo $pdf -> Text ;		// or : echo ( string ) $pdf ;

	Or :

		$pdf	=  new PdfToText ( ) ;
		$pdf -> Load ( 'sample.pdf' ) ;
		echo $pdf -> Text ;


    AUTHOR
        Christian Vigh, 04/2016.

    CREDITS
	I was recently asked at work to implement a pdf text extractor. They provided me with an existing PHP
	source code which consisted in a set of functions (not a class). Alas, the name of the author was not
	present in the source code but I have noticed that two or three classes at http://www.phpclasses.org
	were reusing the set of functions he/she had implemented, because they kept the same names for the
	methods : getTextUsingTransformations, getCharTransformations, getDecodedStream and so on.
	Although the original code was not working for more complex cases, it did a rather good job. Anyway,
	apart from the invaluable understanding of the pdf file format this sample code gave to me, I only
	borrowed two functions, decodeAsciiHex and decodeAscii85, which decode pdf streams using methods I was
	not aware of. However, I could not test them since I have had no sample pdf files using these encoding
	methods.
	This work has also been inspired from that of Adeel Ahmad Khan (https://github.com/adeel/php-pdf-parser)
	which gave me further understanding of the pdf file format.
	And, of course, the PDF file format reference :
		http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf
	I didn't take time to thoroughly read this 1300 pages-long document, since I only had limited time to
	implement that and, thanks to the contributors listed above, I was able to implement it in 1.5 days
	(in PHP4). This current class is a complete reworking for PHP 5 of my initial work, which should be
	able to handle more complicated situations.

    TESTING
	I tested this class with various samples from various origins : Acrobat, PdfCreator, Word and so on.
	I even used it to extract text from the PDF reference document and from the Microsoft Rich Text format
	specification 1.9 (available here : https://www.microsoft.com/en-us/download/details.aspx?id=10725).
	All provided acceptable results.

    LIMITATIONS
	As this class generates text, don't expect the original formatting to be preserved. I have made my best
	to compensate this, but since PDF uses special drawing instructions to position the text on the page,
	it was not possible to handle all the cases. I found especially that documents generated by PdfCreator
	were more difficult to render than other converters, since it uses a combination of absolute positioning
	instructions followed by relative ones. So my advice in this case, if the results are not satisfactory,
	is to use Acrobat or Word to save again your original document in PDF format.

    PDF FILE FORMAT
	I will focus here on the small subparts of the PDF file format that are of interest in the process of
	extracting textual information from a file.

	If you edit a PDF file using an editor such as Notepad++, you will see something like that :

		%PDF-1.4
		%«Ïè¢
		5 0 obj
		<</Length 6 0 R/Filter /FlateDecode>>
		stream
			... binary data ...
		endobj
		...
		7 0 obj
		<</BaseFont/AKCXNM+Calibri/FontDescriptor 8 0 R/ToUnicode 11 0 R/Type/Font
		/FirstChar 1/LastChar 59/Subtype/TrueType>>
		endobj

	The first line indicates the PDF version that was used to generate the file. Then you will see a list
	of declarations looking like :

		x 0 obj
			...
		endobj

	These are the objects that constitute your pdf document. An object can contain textual data, such as
	object #7 in the above example, or a binary stream delimited by the stream/endstream keywords, and
	preceded by options specified in ascii text. The format of the encoded binary stream is given by the
	/Flate, /Ascii85 or /AsciiHex options.

	Apart from the options understood by the PDF renderer, you won't be able to find any plain text in
	your pdf document. This one has been put in "obj" declarations and encoded within a stream, and you will
	need to decode it first.

	There are three types of objects that are of interest to us :
	- Objects containing the document text : there are encoded within a stream, and contain PDF drawing
	  instructions.
	- Font declarations : they specify the name of the fonts we use in the document.
	- Character maps : fonts can use characters maps (which can be seen as substitution tables) by
	  providing a "/ToUnicode x" option, where "x" is the character map object id

	FONT DECLARATIONS
		So far, I have found that font declarations can take two forms :

			7 0 obj
			<</BaseFont/AKCXNM+Calibri/FontDescriptor 8 0 R/ToUnicode 11 0 R/Type/Font
			/FirstChar 1/LastChar 59/Subtype/TrueType>>
			endobj

		or :

			9 0 obj
			<</R7 20 0 R/R9 22 0 R>>
			<</BaseFont/AKCXNM+Calibri/FontDescriptor 8 0 R/ToUnicode 11 0 R/Type/Font
			/FirstChar 1/LastChar 59/Subtype/TrueType>>
			<</BaseFont/AKCXNM+Courier/FontDescriptor 8 0 R/ToUnicode 14 0 R/Type/Font
			/FirstChar 1/LastChar 59/Subtype/TrueType>>
			endobj

		Note that these declerations are delimited with doubled angle-brackets "<<" and ">>".

		The first example specifies a font whose id will be that of its enclosing object, ie #7. Text
		drawing instructions will set it as the current font by using the "/R7" operator (see
		"TEXT BLOCKS" later in this paragraph). It also uses a character map, #11, which is the id
		of the object holding this character map.

		The second example specifies two fonts, using character maps #11 and #14, respectively. Since
		their id cannot be the object number, #9, because they cannot share the same id, a additional
		declaration has been put :

			<</R7 20 0 R/R9 22 0 R>>

		This means that the first font in the declaration will be set using the "/R7" operator when
		used in text blocks, and the second with "/R9".

		Although font declarations usually appear in clear text, they also can be encoded as a stream.

	CHARACTER MAPS
		Character maps are to be seen as substitution tables for characters. They can have two forms
		(at least) ; the first one is for individual character substitution :

			n beginbfchar
			srcCode dstString
			endbfchar

		For example :

			1 beginbfchar
			<3A51><D840DC3E>
			endbfchar

		This means that any reference in a text drawing block to the unicode character \u3A51 will be
		replaced with the sequence \uD840\uDC3E.

		The second type of substitution table works on ranges of characters ; it can have two forms, as
		show in the following example :

			2 beginbfrange
			<0000><005E><0020>
			<005F><0061>[ <00660066> <00660069> <00660066006C> ]
			endbfrange

		The first mapping says : "map characters from the range \u0000..\u005E to \u0020..\u007E". The
		second one, using an array notation, says :
		. Map \u005F to \u0066+\u0066
		. Map \u0060 to \u0066+\u0069
		. Map \u0061 to \u0066+\u0066+\u006C

		I have seen no example of character maps being in clear text. They are (normally) encoded in a
		stream.

		The whole stuff is presented this way within an object :

			16 0 obj
			<< /Length 433 >>
			stream
			/CIDInit /ProcSet findresource begin
			12 dict begin
			begincmap
			/CIDSystemInfo
			<< /Registry ( Adobe )
			/Ordering ( UCS )
			/Supplement 0
			>> def
			/CMapName /Adobe?Identity?UCS def
			/CMapType 2 def
			1 begincodespacerange
			< 0000 >< FFFF >
			endcodespacerange
			2 beginbfrange
			< 0000 >< 005E >< 0020 >
			< 005F >< 0061 >[ < 00660066 > < 00660069 > < 00660066006C > ]
			endbfrange
			1 beginbfchar
			<3A51><D840DC3E>
			endbfchar
			endcmap
			CMapName currentdict /CMap defineresource pop
			end
			end
			endstream
			endobj

		The object number being the one referenced by the /ToUnicode option of a font declaration.

	CHARACTER MAPS II
		Another form of character map can be specified in a font declaration using the following
		form :

			/Encoding x 0 R

		where "x" is the number of an object containing  a definition of the form :

			<</Type/Encoding/BaseEncoding/WinAnsiEncoding/Differences[
			1/C/h/r/i/s/t/a/n/space/V/g/S/o/m/e/d
			/seven/two/zero/L/M/l/colon/c/period/v/at/f]>>

		Each character in the text to be drawn references an entry in this table, where substitutions
		are specified between angle brackets.

	TEXT DRAWING OBJECTS
		Text drawing objects contain a sequence of operators for drawing text. They are too numerous
		to be listed here, but the ones that are of interest for us are described below :

		- BT, ET :
			"BT" starts a text drawing sequence, "ET" ends it. All the following instructions
			are enclosed between "BT" and "ET" keywords.
		- /Rx :
			Set font "x" as the current font.
		- a b c d x y Tm :
			Defines the "text matrix" for the current drawing. "text matrix" is not a quickly
			understandable notion if you rapidly browsed the pdf specification as I did, but
			just keep in mind that the next text drawing instruction will be located at position
			(x,y).
			Why trying to interpret this since the PdfToText class do not handle positioning ?
			The reason is simple ; I have had a sample pdf file which contained the following :

				Mail : someone@somewhere.com

			The code from the Unknown Contributor gave this :

				Mail
				:
				someone@somewhere.com

			The colon character was shown on a separate line (using the Unknown Contributor
			code, the email also vanished from the output, but I did not find the reason why).
			This was due to the fact that the generated pdf code was :

				0 0 0 0 70 570.11 Tm
				[(Mai)3.222(l)2.147( )4.445] TJ
				0 0 0 0 111.15 570.11 Tm
				[(: )] TJ
				0 0 0 0 120.75 570.11 Tm
				[(someone)4.445(@)3.125(somewhere.com)] TJ

			(see below for an explanation on text output operators).
			This meant that, for some unknown reason, the text was output in three parts :
			"mail ", ": " and "someone@somewhere.com". However, the "Tm" operator was used before
			each text output, repositioning the y-coordinate to 570.11.
			The PdfToText class handles the catenation of texts having the same y-coordinate in the
			case where Tm instructions are used ; note however that it will not correctly handle
			text output if the x-coordinates are not sorted in ascending order

		- (sometext)' 		or :
		  [(text1)delta1(text2)delta2...(textn)] TJ or Tj :
			Outputs the specified text and positions to the next line. The text to be output is
			always enclosed with parentheses.
			The first form uses raw text output with default spacing between characters.
			The second form (array form) can specify positive or negative spacing adjustments
			between characters (delta1 to deltan).
			The specification of the text to be output can take two forms, depending on whether
			the current font has an associated character map or not.
			- Fonts without an associated character map :
				Every character will be interpreted as is, except if an escape sequence is
				used. Escape sequences are the same as in the C language : \b for backspace,
				\f for form feed, \t for tab, \r for carriage return, \n for newline.
				Escape sequences are also used for special characters ; for example, displaying
				a closing parenthesis will be specified as this :

					[(\))...] TJ
			- Fonts with an associated character map :
				Each character to be output is an indirection through the character map table.
				For example, if you have the following character map :

					2 beginbfrange
					<0001><0001><0020>
					<0002><0002><0041>
					endbfrange

				(which thanslates character \u0001 to a space, and character \u0002 to uppercase
				A), the text " A " will be specified as :

					[(SOH)delta1(STX)delta2(SOH)] TJ

				Where "SOH" and "STX" are the official Ascii names for character 1 and 2,
				respectively.

				Beware ! C-like escape sequences are not handled (except for escaping special
				characters such as ")"), but indexes 10 and 13 in the character map will always
				be represented as "\n" and "\r" respectively.

    HISTORY
    [Version : 1.0]	[Date : 2016/04/16]     [Author : CV]
        Initial version.

    [Version : 1.0.1]	[Date : 2016/05/12]     [Author : CV]
	. Added code to ignore page headers and footers, which caused unnecessary newlines to be added to the
	  output (handling page headers and footers would require to break the code).
	. The last y-position was not correctly tracked in some cases.

    [Version : 1.1]	[Date : 2016/05/21]     [Author : CV]
	. Added support to retrieve the page number associated to a character offset in the Text contents. New
	  methods are :
	  - GetPageFromOffset
	  - text_strpos/text_stripos
	  - document_strpos/document_stripos
	  - text_match/document_match

    [Version : 1.2.1]	[Date : 2016/05/28]     [Author : CV]
	. Changed the regular expression to match stream/endstream constructs because it captured too much as
	  in the following example :

		<< ... /Type /Stream >>
		stream 
			...
		endstream

	  (the captured data was : " >>\nstream..."). Now a stream construct is detected if not preceded by a
	  slash.
	. Found one case where the beginbfchar/enbfchar and all its contents were put on one line, thus making
	  the regular expression for capturing characters to fail. Hope this will not happen with beginbfrange...

    [Version : 1.2.2]	[Date : 2016/05/31]     [Author : CV]
	. Modified the PdfTexterUnicodeMap class to handle cases where substitutions in beginbfchar/endbfchar
	  constructs contains several characters. For example :

		<012B> <00660067>

	  which means that a reference to character #012B must be substituted with #0066 and #0067.

    [Version : 1.2.3]	[Date : 2016/06/01]     [Author : CV]
	. Found a PDF coming from MAC outer galaxies where some lines were terminated by "\r\n", and some other
	  by "\r".
	. Added more debugging messages when the $DEBUG static class variable is set to an integer value
	  greater than 1.
	. Character references to a CMAP can be specified as \xyz, where "xyz" are octal digits
	. The begincmap/endcmap constructs can be omitted, which initially was the criteria to determine if the
	  current object is a character map. Checked for the presence of beginbfchar/beginbfrange in this case.

    [Version : 1.2.4]	[Date : 2016/06/03]     [Author : CV]
	. Introduced the PdfObjectBase class, from which all the classes defined here inherit. Moved all general
	  methods at this level.
	. Added the PdfPageMap class

    [Version : 1.2.5]	[Date : 2016/06/07]     [Author : CV]
	. Tried to enhance performance by first looking for objects that contain stream/endstream constructs, 
	  to avoid unnecessary detections of character maps, font definitions, etc.
	. Consecutive text shapes introduced by the "Do" instruction were gathered on the same text line.  A
	  line break is now inserted when a "Do" instruction is encountered.

    [Version : 1.2.6]	[Date : 2016/06/08]     [Author : CV]
	. Stream/endstream contents can be unencoded and appear in clear text ! Added the PDF_TEXT_ENCODING 
	  constant to handle this case.
	. Changed the regular expression in IsFontMap() to allow spaces between "<<" and the first "/F". 
	. Character maps strike again ! after the issue uncovered in version 1.2.2, where constructs such as :

		<012B> <00660067>

	  means "replace every reference to 0x0012B with unicode characters 0x0066 and 0x0067 (for maps having 
	  a width of 2 bytes), I discovered that some pdf documents having character maps of 1 byte could hold 
	  entries such as :

		<03> <0020>

	  which simply means "replace every reference to 0x03 with character 0x20"... I have not seen any 
	  differentiating factor between the sample I handled in version 1.2.2 and this one. All I can say is
	  that I put a horrible kludge in PdfTexterUnicodeMap::offsetGet(), to handle a situation were 
	  character widths are one-byte long, and their substitutions can be 2-bytes long, with a leading byte
	  of zero. S..t.

    [Version : 1.2.7]	[Date : 2016/06/11]     [Author : CV]
	. Added the Images array property, which makes available the images found in the document. The elements
	  of this array are image data.
	. Added a few PDF_*_ENCODING constants which were missing. Not all encoding types have been implemented,
	  however.
	. Added the IsImage() and DecodeImage() methods.
	. Added the PdfImage class
	. To simplify the management of this source between the Thrak framework and the specific version made
	  for publishing on phpclasses, added the following :
	  - error() and warning() functions
	  - PdfToTextException class

    [Version : 1.2.8]	[Date : 2016/06/12]     [Author : CV]
	. Corrected the visibility of the Isxxx() methods, which were public instead of protected.
	. Some positioning instructions can be cumulated (a 'Tm' can be followed by a 'Td'). Consider that the
	  last instruction wins.

    [Version : 1.2.9]	[Date : 2016/06/15]     [Author : CV]
	. Array of characters which included line breaks were not correctly interpreted
	. Added the Separator property, which can be used to separate chunks of text that are recognized to be
	  on the same line. This is useful for pdf documents that contain mainly tabular data, but it could
	  break words if it contains textual data.
	. Handled a new strange way to specify font numbers (/f-x-y instead of /Fx).

    [Version : 1.2.10]	[Date : 2016/06/16]     [Author : CV]
	. The character after an octal notation was skipped. For example, (\101 X) was rendered as "AX" instead
	  of "A X".

    [Version : 1.2.11]	[Date : 2016/06/19]     [Author : CV]
	. Renamed the "Separator" property to "BlockSeparator"
	. The "Separator" property is now used as a separator for notations such as :
		[(1)-1000(2)]
	  where "-1000" is a value that is subtracted to the current x-position. Some pdf documents presenting
	  tabular data use this characteristic to separate text in columns. The default value is " " (white
	  space).
	. Added the PDFOPT_* option constants, which can either be specified to the class constructor or changed
	  by setting the new "Options" property. The only flag available for now is PDFOPT_REPEAT_SEPARATOR, which
	  has an interest if the offset between two text chunks is less than -2000 ; for example, the following
	  construct :

		[(1)-2000(2)]

	  will give the string "1 2" if the PDF_REPEAT_SEPARATOR flag is not set, and "1  2" if set (assuming
	  the Separator property is set to a space).

    [Version : 1.2.12]	[Date : 2016/06/21]     [Author : CV]
	. Better handle relative positioning instructions so that text parts supposed to be on the same line 
	  stay on the same line.
	. Added the PageSeparator property

    [Version : 1.2.13]	[Date : 2016/06/23]     [Author : CV]
	. Took into account the relative x-offset specified with Td/TD instructions
	. Added the MinSpaceWidth property, which is to be measured in thousands of text units, to help the
	  class determine if spaces should be inserted between two character units. The default value is 250.
	  Although the value can be less than 1000, only a multiple of 1000 units will determine the total
	  number of spaces to be inserted if the PDF_REPEAT_SEPARATOR flag is set in the Options property.
	. Relaxed a little bit the cases where a newline should be inserted
	. Don't add the BlockSeparator string if the Separator and BlockSeparator properties are the same, and
	  the current result ends with the Separator string. When both properties are set to a space, this 
	  avoids inserting double space between column elements.

    [Version : 1.2.14]	[Date : 2016/06/24]     [Author : CV]
	. Added the __get_character_padding() method to compute the number of spaces needed between two 
	  chunks of characters, taking into account the MinSpaceWidth property.

    [Version : 1.2.15]	[Date : 2016/06/30]     [Author : CV]
	. Corrected the __extract_chars_from_array() methods, which incorrectly handled escaped characters in
	  text groups and ate up the next character following the escaped one. For example, the following group :
		[(3)-3(4)-3(.)11(5)-3(\(f\) a)9(n)4(d)-3( 3)6(4)-3(.6\()6(g)-3(\)\()8(2)4(\), )4(t)-3(h)-3(a)8(t)]
	  was represented as :
		34.5(f)nd 34.6(g)2)that
	  instead of :
		34.5(f) and 34.6(g)(2), that		

    [Version : 1.2.16]	[Date : 2016/07/01]     [Author : CV]
	. No line break was inserted when relative positioning instructions (Td and TD) were encountered. This
	  caused consecutive lines to be joined together.

 **************************************************************************************************************/


/*==============================================================================================================

    class PdfToTextException -
        Implements an exception thrown when an error is encountered while decoding PDF files.

  ==============================================================================================================*/
class  PdfToTextException		extends  \Exception
   { 
	public static	$IsObject		=  false ;

	public function  __construct ( $message, $object_id = false )
	   {
		$text	=  "Pdf decoding error" ;

		if  ( $object_id  !==  false )
			$text	.=  " (object #$object_id)" ;

		$text	.=  " : $message" ;

		parent::__construct ( $text ) ;
	    }
    }


if  ( ! function_exists ( 'warning' ) )
   {
	function  warning ( $message )
	   {
		trigger_error ( $message, E_USER_WARNING ) ;
	    }
    }


if  ( ! function_exists ( 'error' ) )
   {
	function  error ( $message )
	   {
		if  ( is_string ( $message ) )
			trigger_error ( $message, E_USER_ERROR ) ;
		else if (  is_a ( $message, '\Exception' ) )
			throw $message ;
	    }
    }


/*==============================================================================================================

    class PfObjectBase -
        Base class for all PDF objects defined here.

  ==============================================================================================================*/
abstract class  PdfObjectBase		// extends  Object
   {
	// Possible encoding types for streams inside objects ; "unknown" means that the object contains no stream
	const 	PDF_UNKNOWN_ENCODING 		=   0 ;		// No stream decoding type could be identified
	const 	PDF_ASCIIHEX_ENCODING 		=   1 ;		// AsciiHex encoding - not tested
	const 	PDF_ASCII85_ENCODING		=   2 ;		// Ascii85 encoding - not tested
	const 	PDF_FLATE_ENCODING		=   3 ;		// Flate/deflate encoding
	const	PDF_TEXT_ENCODING		=   4 ;		// Stream data appears in clear text - no decoding required
	const	PDF_LZW_ENCODING		=   5 ;		// Not implemented yet
	const	PDF_RLE_ENCODING		=   6 ;		// Runtime length encoding ; not implemented yet
	const	PDF_DCT_ENCODING		=   7 ;		// JPEG images
	const	PDF_CCITT_FAX_ENCODING		=   8 ;		// CCITT Fax encoding - not implemented yet
	const	PDF_JBIG2_ENCODING		=   9 ;		// JBIG2 filter encoding (black/white) - not implemented yet
	const	PDF_JPX_ENCODING		=  10 ;		// JPEG2000 encoding - not implemented yet


	public function  __construct ( )
	   { 
		// parent::__construct ( ) ; 
	    }


 	/*--------------------------------------------------------------------------------------------------------------

	    IsCharacterMap -
	        Checks if the specified text contents represent a character map definition or not.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  IsCharacterMap  ( $decoded_data )
	   {
		return ( stripos ( $decoded_data, 'begincmap' )  	!==  false  ||
			 stripos ( $decoded_data, 'beginbfchar' )  	!==  false  ||		// "begincmap" does not seem to be mandatory...
			 stripos ( $decoded_data, 'beginbfrange' )  	!==  false  ||	
			 stripos ( $decoded_data, '/Differences' )	!==  false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    IsFont -
		Checks if the current object contents specify a font declaration.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  IsFont ( $object_data )
	   {
		return ( stripos ( $object_data, '/BaseFont' )  !==  false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    IsFontMap -
		Checks if the code contains things like :
			<</F1 26 0 R/F2 22 0 R/F3 18 0 R>>
		which maps font 1 (when specified with the /Fx instruction) to object 26, 2 to object 22 and 3 to 
		object 18, respectively, in the above example.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  IsFontMap ( $object_data )
	   {
		if  ( preg_match ( '#<< \s* (/F \d+) | (/f-\d+-\d+) \s+ .* >>#msx', $object_data ) )
			return ( true ) ;
		else
			return ( false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    IsImage -
		Checks if the code contains things like :
			/Subtype/Image

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  IsImage ( $object_data )
	   {
		if  ( preg_match ( '#/Subtype \s* /Image#msx', $object_data ) )
			return ( true ) ;
		else
			return ( false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        IsText - Check if the specified object contents denote a text stream.

	    PROTOTYPE
	        $status		=  $this -> IsText ( $object_data, $decoded_stream_data ) ;

	    DESCRIPTION
	        Checks if the specified object contents denote a text stream.

	    PARAMETERS
	        $object_data (string) -
	                Object data, ie the contents located between the "obj" and "endobj" keywords.

	        $decoded_stream_data (string) -
	        	The flags specified in the object data are not sufficient to be sure that we have a block of
	        	drawing instructions. We must also check for certain common instructions to be present.

	    RETURN VALUE
	        True if the specified contents MAY be text contents, false otherwise.

	    NOTES
		I do not consider this method as bullet-proof. There may arise some cases where non-text blocks can be
		mistakenly considered as text blocks, so it is subject to evolve in the future.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  IsText ( $object_data, $decoded_stream_data )
	   {
		if  ( stripos ( $object_data, '/Filter'  )  !==  false  &&
		      stripos ( $object_data, '/Length'  )  !==  false  &&
		      stripos ( $object_data, '/Length1' )  ===  false  &&
		      stripos ( $object_data, '/Type'    )  ===  false  &&
		      stripos ( $object_data, '/Subtype' )  ===  false )
		   {
		   	if  ( preg_match ( '/\\b(BT|Tf|Td|TJ|Tj|Tm)\\b/', $decoded_stream_data ) )
				return ( true ) ;
		    }
		else if  ( preg_match ( '/\\b(BT|Tf|Td|TJ|Tj|Tm)\\b/', $decoded_stream_data ) )
			return ( true ) ;

		return ( false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        GetEncodingType - Gets an object encoding type.

	    PROTOTYPE
	        $type	=  $this -> GetEncodingType ( $object_id, $object_data ) ;

	    DESCRIPTION
	        When an object is a stream, returns its encoding type.

	    PARAMETERS
		$object_id (integer) -
			PDF object number.

	        $object_data (string) -
	                Object contents.

	    RETURN VALUE
	        Returns one of the following values :

		- PdfToText::PDF_ASCIIHEX_ENCODING :
			Hexdecimal encoding of the binary values.
			Decoding algorithm was taken from the unknown contributor and not tested so far, since I
			couldn't find a PDF file with such an encoding type.

		- PdfToText::PDF_ASCII85_ENCODING :
			Obscure encoding format.
			Decoding algorithm was taken from the unknown contributor and not tested so far, since I
			couldn't find a PDF file with such an encoding type.

		- PdfToText::PDF_FLATE_ENCODING :
			gzip/deflate encoding.

		- PdfToText::PDF_TEXT_ENCODING :
			Stream data is unencoded (ie, it is pure ascii).

		- PdfToText::PDF_UNKNOWN_ENCODING :
			The object data does not specify any encoding at all. It can happen on objects that do not have
			a "stream" part.

		- PdfToText::PDF_DCT_ENCODING :
			a lossy filter based on the JPEG standard.

		The following constants are defined but not yet implemented ; an exception will be thrown if they are
		encountered somewhere in the PDF file :

		- PDF_LZW-ENCODING :
			a filter based on LZW Compression; it can use one of two groups of predictor functions for more 
			compact LZW compression : Predictor 2 from the TIFF 6.0 specification and predictors (filters) 
			from the PNG specification

		- PDF_RLE_ENCODING :
			a simple compression method for streams with repetitive data using the run-length encoding 
			algorithm and the image-specific filters.

		PDF_CCITT_FAX_ENCODING :
			a lossless bi-level (black/white) filter based on the Group 3 or Group 4 CCITT (ITU-T) fax 
			compression standard defined in ITU-T T.4 and T.6.

		PDF_JBIG2_ENCODING :
			a lossy or lossless bi-level (black/white) filter based on the JBIG2 standard, introduced in 
			PDF 1.4.

		PDF_JPX_ENCODING :
			a lossy or lossless filter based on the JPEG 2000 standard, introduced in PDF 1.5.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  GetEncodingType ( $object_id, $object_data )
	   {
		$status 	=  preg_match ( '# / (?P<encoding> (ASCIIHexDecode) | (ASCII85Decode) | (FlateDecode) | (DCTDecode) | ' .
						                   '(LZWDecode) | (RunLengthDecode) | (CCITTFaxDecode) | (JBIG2Decode) | (JPXDecode) ) #imsx', $object_data, $match ) ;

		if  ( ! $status )
			return ( self::PDF_TEXT_ENCODING ) ;

		switch ( strtolower ( $match [ 'encoding' ] ) )
		    {
		    	case 	'asciihexdecode' 	:  return ( self::PDF_ASCIIHEX_ENCODING ) ;
		    	case 	'ascii85decode' 	:  return ( self::PDF_ASCII85_ENCODING  ) ;
		    	case	'flatedecode'		:  return ( self::PDF_FLATE_ENCODING    ) ;
			case    'dctdecode'		:  return ( self::PDF_DCT_ENCODING      ) ;

			case	'lzwdecode'		:
			case	'runlengthdecode'	: 
			case	'ccittfaxdecode'	:
			case	'jbig2decode'		: 
			case	'jpxdecode'		:
				error ( "Encoding type \"{$match [ 'encoding' ]}\" not yet implemented for pdf object #$object_id." ) ;

			default				:  return ( self::PDF_UNKNOWN_ENCODING  ) ;
		     }
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        GetObjectReferences - Gets object references from a specified construct.
	
	    PROTOTYPE
	        $status		=  $this -> GetObjectReferences ( $object_id, $object_data, $searched_string, &$object_ids ) ;
	
	    DESCRIPTION
	        Certain parameter specifications are followed by an object reference of the form :
			x 0 R
		but it can also be an array of references :
			[x1 0 R x2 0 R ... xn 0 r]
		Those kind of constructs can occur after parameters such as : /Pages, /Contents, /Kids...
		This method extracts the object references found in such a construct.
	
	    PARAMETERS
	        $object_id (integer) -
	                Id of the object to be analyzed.

		$object_data (string) -
			Object contents.

		$searched_string (string) - 
			String to be searched, that must be followed by an object or an array of object references.
			This parameter can contain constructs used in regular expressions. Note however that the '#'
			character must be escaped, since it is used as a delimiter in the regex that is applied on
			object data.

		$object_ids (array of integers) -
			Returns on output the ids of the pdf object that have been found after the searched string.
	
	    RETURN VALUE
	        True if the searched string has been found and is followed by an object or array of object references,
		false otherwise.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  GetObjectReferences ( $object_id, $object_data, $searched_string, &$object_ids )
	   {
		$status		=  true ;
		$object_ids	=  [] ;

		if  ( preg_match ( "#$searched_string \s+ (?P<object> \d+) \s+ \d+ \s+ R#ix", $object_data, $match ) )
		   {
			$object_ids []	=  ( integer ) $match [ 'object' ] ;
		    }
		else if  ( preg_match ( "#$searched_string \s* \\[ (?P<objects> [^\]]+ ) \\]#ix", $object_data, $match ) )
		   {
			$object_list	=  $match [ 'objects' ] ;

			if  ( preg_match_all ( '/(?P<object> \d+) \s+ \d+ \s+ R/x', $object_list, $matches ) )
			   {
				foreach  ( $matches [ 'object' ]  as  $id )
					$object_ids []	=  ( integer ) $id ;
			    }
			else
				$status		=  false ;
		    }
		else
			$status		=  false ;

		return ( $status ) ;
	    }

   }


/*==============================================================================================================

    PdfToText class -
	A class for extracting text from Pdf files.

 ==============================================================================================================*/
class  PdfToText 	extends PdfObjectBase
   {
	// Pdf processing options
	const		PDFOPT_NONE				=  0x0000 ;
	const		PDFOPT_REPEAT_SEPARATOR			=  0x0001 ;

	// When boolean true, outputs debug information about fonts, character maps and drawing contents.
	// When integer > 1, outputs additional information about other objects.
	public static 		$DEBUG 		=  false ;

	// Current filename
	public 		$Filename 		=  false ;
	// Extracted text
	public		$Text			=  '' ;
	// Document pages (array of strings)
	public		$Pages			=  [] ;
	// Document images (array of PdfImage objects)
	public		$Images			=  [] ;
	// Text chunk separator (used to separate blocks of text specified as an array notation)
	public		$BlockSeparator		=  '' ;
	// Separator used to separate text groups where the offset value is less than -1000 thousands of character units
	// (eg : [(1)-1822(2)] will add a separator between the characters "1" and "2")
	// Note that such values are expressed in thousands of text units and subtracted from the current position. A 
	// negative value means adding more space between the two text units it separates.
	public		$Separator		=  ' ' ;
	// Separator to be used between pages in the $Text property
	public		$PageSeparator		=  "\n" ;
	// Minimum value (in 1/1000 of text units) that separates two text chunks that can be considered as a real space
	public		$MinSpaceWidth		=  250 ;
	// Pdf options
	public		$Options		=  self::PDFOPT_NONE ;

	// Font mappings
	protected 	$FontTable		=  false ;
	// Page map object
	protected	$PageMap ;
	// Page locations (start and end offsets)
	protected	$PageLocations ;


	/*--------------------------------------------------------------------------------------------------------------

	    CONSTRUCTOR
	        $pdf	=  new PdfToText ( $filename = null, $options = PDFOPT_NONE ) ;

	    DESCRIPTION
	        Builds a PdfToText object and optionally loads the specified file's contents.

	    PARAMETERS
	        $filename (string) -
	                Optional PDF filename whose text contents are to be extracted.

		$options (integer) -
			A combination of PDFOPT_* flags. This can be any of the following :

			- PDFOPT_REPEAT_SEPARATOR :
				Text constructs specified as an array are separated by an offset which is expressed as
				thousands of text units ; for example :

					[(1)-2000(2)]

				will be rendered as the text "1  2" ("1" and "2" being separated by two spaces) if the
				"Separator" property is set to a space (the default) and this flag is specified.
				When not specified, the text will be rendered as "1 2".

			- PDFOPT_NONE :
				None of the above options will apply.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  	__construct ( $filename = null, $options = self::PDFOPT_NONE )
	   {
		parent::__construct ( ) ;

		$this -> Options	=  $options ;

		if  ( $filename )
			$this -> Load ( $filename ) ;
	    }


	public function  __tostring ( )
	   { return ( $this -> Text ) ; }


	/**************************************************************************************************************
	 **************************************************************************************************************
	 **************************************************************************************************************
	 ******                                                                                                  ******
	 ******                                                                                                  ******
	 ******                                          PUBLIC METHODS                                          ******
	 ******                                                                                                  ******
	 ******                                                                                                  ******
	 **************************************************************************************************************
	 **************************************************************************************************************
	 **************************************************************************************************************/

	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        Load - Loads text contents from a PDF file.

	    PROTOTYPE
	        $pdf -> Load ( $filename ) ;

	    DESCRIPTION
	        Extracts text contents from the specified PDF file. Once processed, text contents will be available
		through the "Text" property.

	    PARAMETERS
	        $filename (string) -
	                Optional PDF filename whose text contents are to be extracted.

	 *-------------------------------------------------------------------------------------------------------------*/
	function  Load ( $filename )
	   {
		// Check if the file exists
		if  ( ! file_exists ( $filename ) )
			error ( new  PdfToTextException ( "File \"$filename\" does not exist." ) ) ;

		// Load its contents
		$contents 	=  file_get_contents ( $filename, FILE_BINARY ) ;

		// Check that this is a PDF file
		if  ( ! preg_match ( '/^ %PDF- (?P<version> \d+ (\. \d+)*) /ix', $contents, $match ) )
			error ( new PdfToTextException ( "File \"$filename\" is not a valid PDF file." ) ) ;

		$this -> PdfVersion 	=  $match [ 'version' ] ;

		// Initializations
		$this -> Text 		=  '' ;
		$this -> FontTable 	=  new PdfTexterFontTable ( ) ;
		$this -> Filename 	=  $filename ;
		$this -> Pages		=  [] ;
		$this -> Images		=  [] ;
		$this -> PageMap	=  new PdfTexterPageMap ( ) ;
		$this -> PageLocations	=  [] ;

		// Extract pdf objects that are enclosed by the "obj" and "endobj" keywords
		if  ( ! preg_match_all ( '/(?P<num> \d+) \s+ \d+ \s+ obj (?P<object> .*?) endobj/imsx', $contents, $object_matches ) )
			return ( false ) ;

		// Character maps encountered so far
		$cmaps			=  [] ;

		// Loop through the objects
		$text		=  [] ;

		for ( $i = 0 ; $i < count ( $object_matches [ 'object' ] ) ; $i ++ )
		   {
		   	$object_data 	=  $object_matches [ 'object' ] [$i] ;
		   	$object_number 	=  ( integer ) $object_matches [ 'num' ] [$i] ;

			$this -> PageMap -> Peek ( $object_number, $object_data ) ;
			$type 		=  $this -> GetEncodingType ( $object_number, $object_data ) ;

			if  ( strpos ( $object_data, 'stream' )  ===  false  ||  ! preg_match ( '#[^/] stream ( (\r? \n) | \r ) (?P<stream> .*?) endstream#imsx', $object_data, $stream_match ) )
			   {
				// Some font definitions are in clear text in an object, some are encoded in a stream within the object
				// We process here the unencoded ones
				if  ( $this -> IsFont ( $object_data ) )
				   {
					$this -> FontTable -> Add ( $object_number, $object_data ) ;
					continue ;
				    }
				// Some character maps may also be in clear text
				else if  ( $this -> IsCharacterMap ( $object_data ) )
				    {
					$cmap	=  PdfTexterCharacterMap::CreateInstance ( $object_number, $object_data ) ;

					if  ( $cmap )
						$cmaps [] 	=  $cmap ;

					continue ;
				    }
				// Check if there is an association between font number and object number
				else if  ( $this -> IsFontMap ( $object_data ) )
		   		   {
					$this -> FontTable -> AddFontMap ( $object_number, $object_data ) ;
					continue ;
				    }
				// Ignore other objects that do not contain an encoded stream
		   		else 
				   {
					if  ( self::$DEBUG  >  1 )
						echo "----------------------------------- UNSTREAMED #$object_number\n$object_data" ;

		   			continue ;
				    }
			    }
			// Extract image data, if any
			else if  ( $this -> IsImage ( $object_data ) )
			   {
				$image	=  $this -> DecodeImage ( $object_number, $stream_match [ 'stream' ], $type ) ;

				if  ( $image  !==  false )
					$this -> Images []	=  $image ;
					
				continue ;
			    }

			// Isolate stream data and try to find its encoding type
			$stream_data 		=  $stream_match [ 'stream' ] ;

			// Ignore this stream if the object does not contain an encoding type (/FLATEDECODE, /ASCIIHEX or /ASCII85)
			if  ( $type  ==  self::PDF_UNKNOWN_ENCODING )
			   {
				if  ( self::$DEBUG  >  1 )
					echo "----------------------------------- UNENCODED #$object_number :\n$object_data" ;

				continue ;
			    }

			// Decode the encoded stream
			$decoded_stream_data 	=  $this -> DecodeData ( $stream_data, $type ) ;

			// Check for character maps
			if  ( $this -> IsCharacterMap ( $decoded_stream_data ) )
			   {
				$cmap	=  PdfTexterCharacterMap::CreateInstance ( $object_number, $decoded_stream_data ) ;

				if  ( $cmap )
					$cmaps [] 	=  $cmap ;
			   }
			// Font definitions
			else if  ( $this -> IsFont ( $decoded_stream_data ) )
			   {
				$this -> FontTable -> Add ( $object_number, $decoded_stream_data ) ;
			    }
			// Plain text (well, in fact PDF drawing instructions)
			else if  ( $this -> IsText ( $object_data, $decoded_stream_data ) )
			   {
				$text [ $object_number ]	=  $decoded_stream_data ;
			    }
			else if  ( self::$DEBUG  >  1 )
				echo "----------------------------------- UNRECOGNIZED #$object_number :\n$decoded_stream_data\n" ;
		    }

		// Associate character maps with declared fonts
		foreach  ( $cmaps  as  $cmap )
			$this -> FontTable -> AddCharacterMap ( $cmap ) ;

		// Current font defaults to -1, which means : take the first available font as the current one.
		// Sometimes it may happen that text drawing instructions do not set a font at all (PdfPro for example)
		$current_font	=  -1 ;

		$this -> Pages	=  [] ;
		$this -> PageMap -> MapObjects ( ) ;

		// Extract text from the collected TEXT elements
		foreach  ( $text  as  $id => $str )
		   {
			$page_number	=  $this -> PageMap [ $id ] ;

			if  ( $page_number  !==  false )
			   {
				$object_text	=  $this -> ExtractText ( $id, $str, $current_font ) ;

				if  ( isset ( $this -> Pages [ $page_number ] ) )
					$this -> Pages [ $page_number ]	.=  $object_text ;
				else
					$this -> Pages [ $page_number ]	 =  $object_text ;
			    }
			else if  ( self::$DEBUG  >  1 )
				echo "----------------------------------- OBJECT WITHOUT PAGE #$id :\n$str\n" ;
		    }

		// Build the page locations (ie, starting and ending offsets)
		$offset		=  0 ;

		foreach  ( $this -> Pages  as  $page )
		   {
			$length				 =  strlen ( $page ) ;
			$this -> PageLocations []	 =  [ 'start' => $offset, 'end' => $offset + $length - 1 ] ;
			$offset				+=  $length ;
		    }

		// And finally, the Text property
		$this -> Text	=  implode ( utf8_encode ( $this -> PageSeparator ), $this -> Pages ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        GetPageFromOffset - Returns a page number from a text offset.
	
	    PROTOTYPE
	        $offset		=  $pdf -> GetPageFromOffset ( $offset ) ;
	
	    DESCRIPTION
	        Given a byte offset in the Text property, returns its page number in the pdf document.
	
	    PARAMETERS
	        $offset (integer) -
	                Offset, in the Text property, whose page number is to be retrieved.
	
	    RETURN VALUE
	        Returns a page number in the pdf document, or false if the specified offset does not exist.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  GetPageFromOffset ( $offset )
	   {
		if  ( $offset  ===  false ) 
			return ( false ) ;

		foreach  ( $this -> PageLocations  as  $page => $location )
		   {
			if  ( $offset  >=  $location [ 'start' ]  &&  $offset  <=  $location [ 'end' ] )
				return ( $page ) ;
		    }

		return ( false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        text_strpos, text_stripos - Search for an occurrence of a string.
	
	    PROTOTYPE
	        $result		=  $pdf -> text_strpos  ( $search, $start = 0 ) ;
	        $result		=  $pdf -> text_stripos ( $search, $start = 0 ) ;
	
	    DESCRIPTION
	        These methods behave as the strpos/stripos PHP functions, except that :
		- They operate on the text contents of the pdf file (Text property)
		- They return an array containing the page number and text offset. $result [0] will be set to the page
		  number of the searched text, and $result [1] to its offset in the Text property
	
	    PARAMETERS
	        $search (string) -
	                String to be searched.

		$start (integer) -
			Start offset in the pdf text contents.
	
	    RETURN VALUE
	        Returns an array of two values containing the page number and text offset if the searched string has
		been found, or false otherwise.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  text_strpos ( $search, $start = 0 )
	   {
		$offset		=  strpos ( $this -> Text, $search, $start ) ;

		if  ( $offset  !==  false )
			return ( [ $this -> GetPageFromOffset ( $offset ), $offset ] ) ;

		return ( false ) ;
	    }


	public function  text_stripos ( $search, $start = 0 )
	   {
		$offset		=  stripos ( $this -> Text, $search, $start ) ;

		if  ( $offset  !==  false )
			return ( [ $this -> GetPageFromOffset ( $offset ), $offset ] ) ;

		return ( false ) ;
	    }




	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        document_strpos, document_stripos - Search for all occurrences of a string.
	
	    PROTOTYPE
	        $result		=  $pdf -> document_strpos  ( $search, $group_by_page = false ) ;
	        $result		=  $pdf -> document_stripos ( $search, $group_by_page = false ) ;
	
	    DESCRIPTION
		Searches for ALL occurrences of a given string in the pdf document. The value of the $group_by_page
		parameter determines how the results are returned :
		- When true, the returned value will be an associative array whose keys will be page numbers and values
		  arrays of offset of the found string within the page
		- When false, the returned value will be an array of arrays containing two entries : the page number
		  and the text offset.

		For example, if a pdf document contains the string "here" at character offset 100 and 200 in page 1, and
		position 157 in page 3, the returned value will be :
		- When $group_by_page is false :
			[ [ 1, 100 ], [ 1, 200 ], [ 3, 157 ] ]
		- When $group_by_page is true :
			[ 1 => [ 100, 200 ], 3 => [ 157 ]
	
	    PARAMETERS
	        $search (string) -
	                String to be searched.

		$group_by_page (boolean) -
			Indicates whether the found offsets should be grouped by page number or not.
	
	    RETURN VALUE
	        Returns an array of page numbers/character offsets (see Description above) or false if the specified
		string does not appear in the document.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  document_strpos ( $text, $group_by_page = false )
	   {
		$length		=  strlen ( $text ) ;

		if  ( ! $length )
			return ( false ) ;

		$result		=  [] ;
		$index		=  0 ;

		while ( ( $index =  strpos ( $this -> Text, $text, $index ) )  !==  false )
		   {
			$page	=  $this -> GetPageFromOffset ( $index ) ;

			if  ( $group_by_page )
				$result [ $page ] []	=  $index ;
			else
				$result []		=  [ $page, $index ] ;

			$index	+=  $length ;
		    }

		return ( $result ) ;
	    }


	public function  document_stripos ( $text, $group_by_page = false )
	   {
		$length		=  strlen ( $text ) ;

		if  ( ! $length )
			return ( false ) ;

		$result		=  [] ;
		$index		=  0 ;

		while ( ( $index =  stripos ( $this -> Text, $text, $index ) )  !==  false )
		   {
			$page	=  $this -> GetPageFromOffset ( $index ) ;

			if  ( $group_by_page )
				$result [ $page ] []	=  $index ;
			else
				$result []		=  [ $page, $index ] ;

			$index	+=  $length ;
		    }

		return ( $result ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        text_match, document_match - Search string using regular expressions.
	
	    PROTOTYPE
	        $status		=  $pdf -> text_match ( $pattern, &$match = null, $flags = 0, $offset = 0 ) ;
	        $status		=  $pdf -> document_match ( $pattern, &$match = null, $flags = 0, $offset = 0 ) ;
	
	    DESCRIPTION
	        text_match() calls the preg_match() PHP function on the pdf text contents, to locate the first occurrence
		of text that matches the specified regular expression.
		document_match() calls the preg_match_all() function to locate all occurrences that match the specified
		regular expression.
		Note that both methods add the PREG_OFFSET_CAPTURE flag when calling preg_match/preg_match_all so you 
		should be aware that all captured results are an array containing the following entries :
		- Item [0] is the captured string
		- Item [1] is its text offset
		- The text_match() and document_match() methods add an extra array item (index 2), which contains the
		  page number where the matched text resides
	
	    PARAMETERS
	        $pattern (string) -
	                Regular expression to be searched.

		$match (any) -
			Output captures. See preg_match/preg_match_all.

		$flags (integer) -
			PCRE flags. See preg_match/preg_match_all.

		$offset (integer) -
			Start offset. See preg_match/preg_match_all.
	
	    RETURN VALUE
	        Returns the number of matched occurrences, or false if the specified regular expression is invalid.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  text_match ( $pattern, &$match = null, $flags = 0, $offset = 0 )
	   {
		$local_match	=  null ;
		$status		=  preg_match ( $pattern, $this -> Text, $local_match, $flags | PREG_OFFSET_CAPTURE, $offset ) ;

		if  ( $status ) 
		   {
			foreach  ( $local_match  as  &$entry )
				$entry [2]	=  $this -> GetPageFromOffset ( $entry [1] ) ;

			$match	=  $local_match ;
		    }

		return ( $status ) ;
	    }


	public function  document_match ( $pattern, &$matches = null, $flags = 0, $offset = 0 )
	   {
		$local_matches	=  null ;
		$status		=  preg_match_all ( $pattern, $this -> Text, $local_matches, $flags | PREG_OFFSET_CAPTURE, $offset ) ;

		if  ( $status ) 
		   {
			foreach  ( $local_matches  as  &$entry )
			   {
				foreach  ( $entry  as  &$subentry )
				$subentry [2]	=  $this -> GetPageFromOffset ( $subentry [1] ) ;
			    }

			$matches	=  $local_matches ;
		    }

		return ( $status ) ;
	    }


	/**************************************************************************************************************
	 **************************************************************************************************************
	 **************************************************************************************************************
	 ******                                                                                                  ******
	 ******                                                                                                  ******
	 ******                                         INTERNAL METHODS                                         ******
	 ******                                                                                                  ******
	 ******                                                                                                  ******
	 **************************************************************************************************************
	 **************************************************************************************************************
	 **************************************************************************************************************/

	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        DecodeData - Decodes stream data.

	    PROTOTYPE
	        $data	=  $this -> DecodeData ( $stream_data, $type ) ;

	    DESCRIPTION
	        Decodes stream data (binary data located between the "stream" and "enstream" directives) according to the
		specified encoding type, given in the surrounding object parameters.

	    PARAMETERS
	        $stream_data (string) -
	                Contents of the binary stream.

		$type (integer) -
			One of the PDF_*_ENCODING constants, as returned by the GetEncodingType() method.

	    RETURN VALUE
	        Returns the decoded stream data.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  DecodeData ( $stream_data, $type )
	   {
		$decoded_stream_data 	=  '' ;

		switch  ( $type )
		   {
		   	case 	self::PDF_FLATE_ENCODING :
		   		$decoded_stream_data 	=  gzuncompress ( $stream_data ) ;
		   		break ;

		   	case 	self::PDF_ASCIIHEX_ENCODING :
		   		$decoded_stream_data 	=  $this -> __decode_ascii_hex ( $stream_data ) ;
		   		break ;

			case 	self::PDF_ASCII85_ENCODING :
				$decoded_stream_data 	=  $this -> __decode_ascii_85 ( $stream_data ) ;
				break ;

			case	self::PDF_TEXT_ENCODING :
				$decoded_stream_data	=  $stream_data ;
				break ;
				
		    }

		return ( $decoded_stream_data ) ;
	    }


	// __decode_ascii_hex -
	//	Decoder for /AsciiHexDecode streams.
	private function __decode_ascii_hex ( $input )
	    {
	    	$output 	=  "" ;
	    	$is_odd 		=  true ;
	    	$is_comment 	=  false ;

	    	for  ( $i = 0, $codeHigh =  -1 ; $i  <  strlen ( $input )  &&  $input [ $i ]  !=  '>' ; $i++ )
	    	   {
	    		$c 	=  $input [ $i ] ;

	    		if  ( $is_comment )
	    		   {
	    			if   ( $c  ==  '\r'  ||  $c  ==  '\n' )
	    				$is_comment 	=  false ;

	    			continue;
	    		    }

	    		switch  ( $c )
	    		   {
	    			case  '\0' :
	    			case  '\t' :
	    			case  '\r' :
	    			case  '\f' :
	    			case  '\n' :
	    			case  ' '  :
	    				break ;

	    			case '%' :
	    				$is_comment 	=  true ;
	    				break ;

	    			default :
	    				$code 	=  hexdec ( $c ) ;

	    				if  ( $code  ===  0  &&  $c  !=  '0' )
	    					return ( '' ) ;

	    				if  ( $is_odd )
	    					$codeHigh 	 =  $code ;
					else
	    					$output 	.=  chr ( ( $codeHigh << 4 ) | $code ) ;

	    				$is_odd 	=  ! $is_odd ;
	    				break ;
	    		    }
	    	    }

	    	if  ( $input [ $i ]  !=  '>' )
	    		return ( '' ) ;

	    	if  ( $is_odd )
	    		$output 	.=  chr ( $codeHigh << 4 ) ;

	    	return ( $output ) ;
	    }


	// __decode_ascii_85 -
	//	Decoder for /Ascii85Decode streams.
	private function  __decode_ascii_85 ( $input )
	    {
	    	$output 	=  "" ;
	    	$is_comment 	=  false ;
	    	$ords 		=  [] ;

	    	for  ( $i = 0, $state = 0  ; $i  <  strlen ( $input )  &&  $input [ $i ]  !=  '~'  ; $i ++ )
	    	   {
	    		$c 	=  $input [ $i ] ;

	    		if ( $is_comment )
	    		   {
	    			if  ( $c  ==  '\r'  ||  $c  ==  '\n' )
	    				$is_comment 	=  false ;

	    			continue ;
	    		    }

	    		if  ( $c  ==  '\0'  ||  $c  ==  '\t'  ||  $c  ==  '\r'  ||  $c  ==  '\f'  ||  $c  ==  '\n'  ||  $c  ==  ' ' )
	    			continue ;

    			if  ( $c  ==  '%' )
    			   {
    				$is_comment 	=  true ;
    				continue ;
    			    }

    			if  ( $c  ==  'z'  &&  $state  ===  0 )
    			   {
    				$output 	.= str_repeat ( chr ( 0 ), 4 ) ;
    				continue ;
    			    }

    			if  ( $c  <  '!'  ||  $c  >  'u' )
    				return ( '' ) ;

    			$code = ord ( $input [ $i ] ) & 0xff ;
    			$ords [ $state++  ] = $code - ord ( '!' ) ;

    			if  ( $state  ==  5 )
    			   {
    				$state 	=  0 ;

    				for  ( $sum = 0, $j = 0  ; $j < 5  ; $j++ )
    					$sum 	=  $sum * 85 + $ords [ $j ] ;

    				for ( $j = 3  ; $j >= 0  ; $j-- )
    					$output 	.=  chr ( $sum >> ( $j * 8 ) ) ;
    			    }
	    	    }

	    	if  ( $state === 1 )
	    		return ( '' ) ;
    		elseif  ( $state > 1 )
    		   {
    			for  ( $i = 0, $sum = 0  ; $i  <  $state  ; $i++ )
    				$sum 	+= ( $ords [ $i ] + ( $i == $state - 1 ) ) * pow ( 85, 4 - $i ) ;

    			for  ( $i = 0  ; $i  <  $state - 1  ; $i++ )
    				$output 	.=  chr ( $sum >> ( ( 3 - $i ) * 8 ) ) ;
    		    }

    		return ( $output ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        DecodeImage - Returns decoded image contents.
	
	    PROTOTYPE
	        TBC
	
	    DESCRIPTION
	        description
	
	    PARAMETERS
	        $object_id (integer) -
	                Pdf object number.

		$object_data (string) -
			Object data.

		$type (integer) -
			One of the PdfToText::PDF_*_ENCODING constants.
	
	    RETURN VALUE
	        description
	
	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  DecodeImage ( $object_id, $object_data, $type )
	   {
		switch  ( $type )  
		   {
			case	self::PDF_DCT_ENCODING :
				return ( new PdfImage ( $object_data ) ) ;

			// For now, I have not found enough information to be able to decode the data in an inflated stream...
			case	self::PDF_FLATE_ENCODING :
				return ( false ) ;

			default :
				error ( new PdfToTextException ( "Image format type #$type not yet implemented for object #$object_id." ) ) ;
		    }
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
		ExtractText - extracts text from a pdf stream.

	    PROTOTYPE
		$text 	=  $this -> __extract_text ( $object_id, $data, &$current_font ) ;

	    DESCRIPTION
	        Extracts text from decoded stream contents.

	    PARAMETERS
	    	$object_id (integer) -
	    		Object id of this text block.

	    	$data (string) -
	    		Stream contents.

		$current_font (integer) -
			Id of the current font, which should be found in the $this->FontTable property, if anything
			went ok.
			This parameter is required, since text blocks may not specify a new font resource id and reuse
			the one that waas set before.

	    RETURN VALUE
		Returns the decoded text.

	    NOTES
		The PDF language can be seen as a stack-driven language  ; for example, the instruction defining a text
		matrix ( "Tm" ) expects 6 floating-point values from the stack :

			0 0 0 0 x y Tm

		It can also specify specific operators, such as /Rx, which sets font number "x" to be the current font,
		or even "<< >>" constructs that we can ignore during our process of extracting textual data.
		Actually, we only want to handle a very small subset of the Adobe drawing language ; These are :
		- "Tm" instructions, that specify, among others, the x and y coordinates of the next text to be output
		- "/R" instructions, that specify which font is to be used for the next text output. This is useful
		  only if the font has an associated character map.
		- "/F", same as "/R", but use a font map id instead of a direct object id.
		- Text, specified either using a single notation ( "(sometext)" ) or the array notation
		  ( "[(...)d1(...)d2...(...)]" ), which allows for specifying inter-character spacing.
		 - "Tf" instructions, that specifies the font size. This is to be able to compute approximately the
		   number of empty lines between two successive Y coordinates in "Tm" instructions
		 - "TL" instructions, that define the text leading to be used by "T*"

		This is why I choosed to decompose the process of text extraction into three steps :
		- The first one, the lowest-level step, is a tokenizer that extracts individual elements, such as "Tm",
		  "TJ", "/Rx" or "510.77". This is handled by the __next_token() method.
		- The second one, __next_instruction(), collects tokens. It pushes every floating-point value onto the
		  stack, until an instruction is met.
		- The third one, ExtractText(), processes data returned by __next_instruction(), and actually performs
		  the (restricted) parsing of text drawing instructions.

	 *-------------------------------------------------------------------------------------------------------------*/
	private function  ExtractText ( $object_id, $data, &$current_font )
	   {
		if  ( self::$DEBUG )
		   {
			echo "----------------------------------- TEXT #$object_id\n" ;
			echo $data ;
		    }

		// Index into the specified block of text-drawing instructions
		$data_index 		=  0 ;

		$data_length 		=  strlen ( $data ) ;		// Data length
		$result 		=  '' ;				// Resulting string

		// Y-coordinate of the last seen "Tm" instruction
		$last_goto_y 		=  -1 ;

		// When true, the current text should be output on the same line as the preceding one
		$use_same_line 		=  false ;

		// Instruction preceding the current one
		$last_instruction 	=  true ;

		// Current font size
		$current_font_size 		=  0 ;

		// Extra newlines to add before the current text
		$extra_newlines 		=  0 ;

		// Text leading used by T*
		$text_leading 			=  0 ;

		// Set to true if a separator needs to be inserted
		$needs_separator		=  false ;

		// A flag to tell if we should "forget" the last instruction
		$discard_last_instruction	=  false ;

		// A flag that tells whether the Separator and BlockSeparator properties are identical
		$same_separators		=  ( $this -> Separator  ==  $this -> BlockSeparator ) ;

		// Loop through instructions
		while  ( ( $instruction =  $this -> __next_instruction ( $data, $data_length, $data_index ) )  !==  false )
		   {
			// Character position after the current instruction
			$data_index 	=  $instruction [ 'next' ] ;

			// Process current instruction
			switch  ( $instruction [ 'instruction' ] )
			   {
				// "Tm", "Td" or "TD" : Output text on the same line, if the "y" coordinates are equal
			   	case 	'goto' :
					// Some text is positioned using 'Tm' instructions ; however they can be immediatley followed by 'Td' instructions
					// which give a relative positioning ; so consider that the last instruction wins
					if  ( $instruction [ 'relative' ] )
					   {
						$last_goto_y	+=  $instruction [ 'y' ]  ;

						// Try to put a separator if the x coordinate is non-zero
						if  ( $instruction [ 'x' ]  >=  $current_font_size )
							$result		.=  $this -> Separator ;

						$discard_last_instruction	=  true ;
						$extra_newlines			=  0 ; 
						$use_same_line			=  ( abs ( $instruction  [ 'y' ] )  <=  $current_font_size ) ;
						
						break ;
					    }

			   		if  ( $instruction [ 'y' ]  ==  $last_goto_y  ||  abs ( $instruction [ 'y' ] - $last_goto_y )  <  $current_font_size )
			   		   {
			   			$use_same_line 		=  true ;
			   			$extra_newlines 	=  0 ;
			   		    }
					else
					   {
					   	// Compute the number of newlines we have to insert between the current and the next lines
					   	if  ( $current_font_size )
					   		$extra_newlines =  ( integer ) ( ( $last_goto_y - $instruction [ 'y' ] - $current_font_size ) / $current_font_size ) ;

						$use_same_line 		=  ( $last_goto_y  ==  -1 ) ;
					    }

					$last_goto_y 		=  $instruction [ 'y' ] ;
			   		break ;

				// "/Rx" : sets the current font
			   	case 	'resource' :
			   		$current_font 		=  $instruction [ 'resource' ] ;
			   		break ;

			   	case 	'fontsize' :
			   		$current_font_size 	=  $instruction [ 'size' ] ;
			   		break ;

			   	// 'TL' : text leading to be used for the next "T*" in the flow
			   	case 'leading' :
			   		$text_leading 		=  $instruction [ 'size' ] ;
			   		break ;

				// An "nl" instruction means TJ, Tj, T* or "'"
			   	case 	'nl' :
			   		if  ( ! $instruction [ 'conditional' ] )
			   		   {
			   		   	if  ( $instruction [ 'leading' ]  &&  $text_leading  &&  $current_font_size )
			   		   	   {
			   		   		$count 	=  ( integer ) ( ( $text_leading - $current_font_size ) / $current_font_size ) ;

			   		   		if  ( ! $count )
			   		   			$count 	=  1 ;
			   		   	    }
			   		   	else
			   		   		$count 	=  1 ;

		   		   		$extra			 =  str_repeat ( PHP_EOL, $count ) ;
			   			$result 		.=  $extra ;
						$needs_separator	 =  false ;
						$last_goto_y 		-=  ( $count * $text_leading ) ;	// Approximation on y-coord change
			   		    }

			   		break ;

				// Raw text (enclosed by parentheses) or array text (enclosed within square brackets)
				// is returned as a single instruction
			   	case 	'text' :
					// Check if we have to insert a newline
			   		if ( ! $use_same_line )
					   {
			   			$result 		.=  PHP_EOL ;
						$needs_separator	 =  false ;
					    }
			   		// Roughly simulate spacing between lines by inserting newline characters
			   		else if  ( $extra_newlines  > 0 )
			   		   {
			   			$result 		.=  str_repeat ( PHP_EOL, $extra_newlines ) ;
			   			$extra_newlines		 =  0 ;
						$needs_separator	 =  false ;
			   		    }

					// Add a separator if necessary
					if  ( $needs_separator )
					   {
						// If the Separator and BlockSeparator properties are the same (and not empty), only add a block separator if
						// the current result does not end with it
						if  ( $same_separators )
						   {
							if  ( $this -> Separator  !=  ''  &&  substr ( $result, - strlen ( $this -> Separator ) )  !=  $this -> BlockSeparator )
								$result		.=  $this -> BlockSeparator ;
						    }
						else
							$result		.=  $this -> BlockSeparator ;
					    }

					$needs_separator	=  true ;
					$value_index		=  0 ;

					// Fonts having character maps will require some special processing
					if  ( $this -> FontTable -> IsMapped ( $current_font ) )
					   {
					   	// Loop through each text value
			   			foreach  ( $instruction [ 'values' ]  as  $text )
			   			   {
			   		   		$is_hex 	=  ( $text [0]  ==  '<' ) ;
			   			   	$length 	=  strlen ( $text ) - 2 ;
			   			   	$text 		=  substr ( $text, 1, $length ) ;

			   			   	// Characters are encoded within angle brackets ( "<>" ).
			   			   	if  ( $is_hex )
			   			   	   {
								$width 	=  $this -> FontTable -> GetMapWidth ( $current_font ) ;

			   			   	   	for  ( $i = 0 ; $i  <  $length ; $i += $width )
			   			   	   	   {
			   			   	   	   	$value 	=  str_pad ( substr ( $text, $i, $width ), $width, '0', STR_PAD_LEFT ) ;
			   			   	   	   	$ch 	=  hexdec ( $value ) ;

			   			   			$result .= $this -> FontTable -> MapCharacter ( $current_font, $ch ) ;
			   			   	   	    }
			   			   	    }
							// Character strings within parentheses.
							// For every text value, use the character map table for substitutions
							else
							   {
				   		   		for  ( $i = 0 ; $i  <  $length ; $i ++ )
				   		   		   {
				   		   			$ch 	=  $text [$i] ;

									// ... but don't forget to handle escape sequences "\n" and "\r" for characters
									// 10 and 13
				   		   			if  ( $ch  ==  '\\' )
				   		   			   {
				   		   				$ch 	=  $text [++$i] ;

				   		   				switch  ( $ch )
				   		   				   {
				   		   					case 	'n' 	:  $ch =  "\n" ; break ;
				   		   					case 	'r' 	:  $ch =  "\r" ; break ;

											// However, an octal form can also be specified ; in this case we have to take into account
											// the character width for the current font (if the character width is 4 hex digits, then we
											// will encounter constructs such as "\000\077").
											// The method used here is dirty : we build a regex to match octal character representations on a substring
											// of the text 
											default :
												$width		=  $this -> FontTable -> GetMapWidth ( $current_font ) / 2 ;	// Convert to byte count
												$subtext	=  substr ( $text, $i - 1 ) ;
												$regex		=  "#^ (\\\\ [0-7]+){1,$width} #imsx" ;

												$status		=  preg_match ( $regex, $subtext, $octal_matches ) ;

												if  ( $status )
												   {
													$octal_values	=  explode ( '\\', substr ( $octal_matches [0], 1 ) ) ;
													$ord		=  0 ;

													foreach  ( $octal_values  as  $octal_value ) 
														$ord	=  ( $ord  <<  8 ) + octdec ( $octal_value ) ;

													$ch	 =  chr ( $ord ) ;
													$i	+=  strlen ( $octal_matches [0] ) - 2 ;
												    }
				   		   				    }
				   		   			    }

									// Add substituted character to the output result
									$result		.=  $this -> FontTable -> MapCharacter ( $current_font, ord ( $ch ) ) ;
				   		   		    }
							    }

							// Handle offsets between blocks of characters
							if  ( isset ( $instruction [ 'offsets' ] [ $value_index ] ) )
								$result		.=  $this -> __get_character_padding ( $instruction [ 'offsets' ] [ $value_index ] ) ;

							$value_index ++ ;
			   		   	    }
			   		    }
					// For fonts having no associated character map, we simply encode the string in UTF8
					// after the C-like escape sequences have been processed
					// Note that <xxxx> constructs can be encountered here, so we have to process them as well
			   		else
			   		   {
			   			foreach  ( $instruction [ 'values' ]  as  $text )
			   			   {
			   			   	$is_hex 	=  ( $text [0]  ==  '<' ) ;
			   			   	$length 	=  strlen ( $text ) - 2 ;
			   			   	$text 		=  substr ( $text, 1, $length ) ;

			   			   	// Characters are encoded within angle brackets ( "<>" )
			   			   	if  ( $is_hex )
			   			   	   {
			   			   	   	for  ( $i = 0 ; $i  <  $length ; $i += 4 )
			   			   	   	   {
			   			   	   	   	$value 	=  str_pad ( substr ( $text, $i, 4 ), 4, '0', STR_PAD_LEFT ) ;
			   			   	   	   	$ch 	=  hexdec ( $value ) ;

			   			   			$result .= mb_convert_encoding ( '&#' . sprintf ( '%d', $ch ) . ';',
			   			   					'UTF-8', 'HTML-ENTITIES' ) ;
			   			   	   	    }
			   			   	    }
			   			   	else
			   					$result 	.=  utf8_encode ( $this -> Unescape ( $text ) ) ;

							// Handle offsets between blocks of characters
							if  ( isset ( $instruction [ 'offsets' ] [ $value_index ] ) )
								$result		.=  $this -> __get_character_padding ( $instruction [ 'offsets' ] [ $value_index ] ) ;

							$value_index ++ ;
			   			   }
			   		    }
			    }

			// Remember last instruction - this will help us into determining whether we should put the next text
			// on the current or following line
			if  ( ! $discard_last_instruction )
				$last_instruction 	=  $instruction ;

			$discard_last_instruction	=  false ;
		    }


		return ( $result ) ;
	    }


	// __next_instruction -
	//	Retrieves the next instruction from the drawing text block.
	function  __next_instruction ( $data, $data_length, $index )
	   {
		static 	$last_instruction 	=  false ;

		// Constructs such as
		if  ( $last_instruction )
		   {
			$result 		=  $last_instruction ;
			$last_instruction	=  false ;

			return ( $result ) ;
		    }

		// Holds the floating-point values encountered so far
		$number_stack 	=  [] ;

		// Used to ignore everything until the last "ET" token (for page headers and footers)
		$ignore		=  false ;

		// Loop through the stream of tokens
		while  ( ( $part = $this -> __next_token ( $data, $data_length, $index ) )  !==  false )
		   {
			$token 		=  $part [0] ;
			$next_index 	=  $part [1] ;

			// If we are in a page header or footer definition, ignore everything
			if  ( $ignore )  
			   {
				if  ( $token  ==  'ET' )
					$ignore		=  false ;

				$index		=  $next_index ;
				continue ;
			    }
			// Otherwise, try to see if we're in a page header or footer description, something like :
			//	<</Attached [/Top]/Type/Pagination/Subtype/Header>>
			// or :
			//	<</Attached [/Bottom]/Type/Pagination/Subtype/Footer>>
			else if  ( preg_match ( '#/Type/Pagination/Subtype/((Header)|(Footer))#ix', $token ) )
			   {
				$ignore		=  true ;
				$index		=  $next_index ;

				continue ;
			    }

			// Floating-point number : push it onto the stack
			if  ( ctype_digit ( $token [0] )  ||  $token [0]  ==  '-'  ||  $token [0]  ==  '+' )
				$number_stack []	=  $token ;
			// 'Tm' instruction : return a "goto" instruction with the x and y coordinates
			else if  ( $token  ==  'Tm' )
			   {
				$x 	=  $number_stack [4] ;
				$y 	=  $number_stack [5] ;

				return ( [ 'instruction' => 'goto', 'next' => $next_index, 'x' => $x, 'y' => $y, 'relative' => false ] ) ;
			    }
			// 'Td' or 'TD' instructions : return a goto instruction with the x and y coordinates (1st and 2nd args)
			else if  ( $token  ==  'Td'  ||  $token  ==  'TD' )
			   {
				$x 	=  $number_stack [0] ;
				$y 	=  $number_stack [1] ;

				return ( [ 'instruction' => 'goto', 'next' => $next_index, 'x' => $x, 'y' => $y, 'relative' => true ] ) ;
			    }
			// Output text "'" instruction, with conditional newline
			else if  ( $token [0]  ==  "'" )
				return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => true, 'leading' => false ] ) ;
			// Same as above
			else if  ( $token  ==  'TJ'  ||  $token  ==  'Tj' )
				return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => true, 'leading' => false ] ) ;
			// Set font size
			else if  ( $token  ==  'Tf' )
				return ( [ 'instruction' => 'fontsize', 'next' => $next_index, 'size' => $number_stack [0] ] ) ;
			// Text leading (spacing used by T*)
			else if  ( $token  ==  'TL' )
				return ( [ 'instruction' => 'leading', 'next' => $next_index, 'size' => $number_stack [0] ] ) ;
			// Position to next line
			else if  ( $token  ==  'T*' )
				return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => false, 'leading' => true ] ) ;
			// Draw object ("Do"). To prevent different text shapes to appear on the same line, we return a "newline" instruction
			// here. Note that the shape position is not taken into account here, and shapes will be processed in the order they
			// appear in the pdf file (which is likely to be different from their position on a graphic screen).
			else if  ( $token  ==  'Do' )
				return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => false, 'leading' => false ] ) ;
			// Raw text output
			else if  ( $token [0]  ==  '(' )
			   {
			   	$next_part 	=  $this -> __next_token ( $data, $data_length, $next_index ) ;
			   	$instruction	=  [ 'instruction' => 'text', 'next' => $next_index, 'values' => [ $token ] ] ;

			   	if  ( $next_part [0]  ==  "'" )
			   	   {
			   	   	$last_instruction  	=  $instruction ;
			   	   	return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => false, 'leading' => true ] ) ;
			   	   }
			   	else
					return ( $instruction ) ;
			    }
		   	else if  ( $token [0]  ==  '<'  &&  ctype_xdigit ( $token [1] ) )
			   {
			   	$next_part 	=  $this -> __next_token ( $data, $data_length, $next_index ) ;
			   	$instruction	=  [ 'instruction' => 'text', 'next' => $next_index, 'values' => [ $token ] ] ;

			   	if  ( $next_part [0]  ==  "'" )
			   	   {
			   	   	$last_instruction  	=  $instruction ;
			   	   	return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => false, 'leading' => true ] ) ;
			   	   }
			   	else
					return ( $instruction ) ;
			    }
			    // Text specified as an array of individual raw text elements, and individual interspaces between characters
			else if  ( $token [0]  ==  '[' )
			   {
				$values 	=  $this -> __extract_chars_from_array ( $token ) ;
				$instruction 	=  [ 'instruction' => 'text', 'next' => $next_index, 'values' => $values [0], 'offsets' => $values [1] ] ;

				return ( $instruction ) ;
			    }
			// "/R" : Specifies the font to be used for the next text output(s)
			else if  ( ! strncasecmp ( $token, '/R', 2 ) )
			   {
				$resource 	=  ( integer ) substr ( $token, 2 ) ;

				return ( [ 'instruction' => 'resource', 'next' => $next_index, 'resource' => $resource ] ) ;
			    }
		   	// "/F" : Specifies the font to be used for the next text output(s), using an indirect id
			else if  ( ! strncasecmp ( $token, '/F', 2 ) )
			   {
				$resource 	=  substr ( $token, 2 ) ;

				if  ( $resource [0]  ==  '-' )
					$resource	=  substr ( $resource, 1 ) ;

				$id 		=  $this -> FontTable -> GetFontByMapId ( $resource ) ;

				return ( [ 'instruction' => 'resource', 'next' => $next_index, 'resource' => $id ] ) ;
			    }
			    // Other instructions : we're not that much interested in them, so clear the number stack and consider
			// that the current parameters, floating-point values, have been processed
			else
				$number_stack 	=  [] ;

			$index 		=  $next_index ;
		    }

		// End of input
		return ( false ) ;
	    }


	// __next_token :
	//	Retrieves the next token from the drawing instructions stream.
	function  __next_token ( $data, $data_length, $index )
	   {
		// Skip spaces
		while  ( $index  <  $data_length  &&  ctype_space ( $data [ $index ] ) )
			$index ++ ;

		// End of input
		if  ( $index  >=  $data_length )
			return ( false ) ;

		// The current character will tell us what to do
		$ch 	=  $data [ $index ] ;

		switch ( $ch )
		   {
			// Opening square bracket : we have to find the closing one, taking care of escape sequences
			// that can also specify a square bracket, such as "\]"
		   	case 	"[" :
		   		$pos 		=  $index + 1 ;
		   		$parent 	=  0 ;
		   		$angle 	=  0 ;
		   		$result		=  $ch ;

		   		while  ( $pos  <  $data_length )
		   		   {
		   			$nch 	=  $data [ $pos ++ ] ;

		   			switch  ( $nch )
		   			   {
		   			   	case 	'(' :
		   			   		$parent ++ ;
		   			   		$result 	.=  $nch ;
		   			   		break ;

		   			   	case 	')' :
		   			   		$parent -- ;
		   			   		$result 	.=  $nch ;
		   			   		break ;

		   			   	case 	'<' :
		   			   		$angle ++ ;
		   			   		$result 	.=  $nch ;
		   			   		break ;

		   			   	case 	'>' :
		   			   		$angle -- ;
		   			   		$result 	.=  $nch ;
		   			   		break ;

		   			   	case 	'\\' :
		   					$result 	.=  $nch . $data [ $pos ++ ] ;
		   					break ;

		   			   	case 	']' :
		   					$result 	.=  ']' ;

		   					if  ( ! $parent  ||  ! $angle )
		   						break  2 ;
		   					else
		   						break ;

						case	"\n" :
						case	"\r" :
							break ;

		   			   	default :
		   			   		$result 	.=  $nch ;
		   			    }
		   		    }

		   		return ( [ $result, $pos ] ) ;

			// Parenthesis : Again, we have to find the closing parenthesis, taking care of escape sequences
			// such as "\)"
		   	case 	"(" :
		   		$pos 		=  $index + 1 ;
		   		$result		=  $ch ;

		   		while  ( $pos  <  $data_length )
		   		   {
		   			$nch 	=  $data [ $pos ++ ] ;

		   			if  ( $nch  ==  '\\' )
					   {
						$after		 =  $data [ $pos ] ;

						// Character references specified as \xyz, where "xyz" are octal digits
						if  ( $after  >=  '0'  &&  $after  <=  '7' )
						   {
							$result		.=  $nch ;

							while  ( $data [ $pos ]  >=  '0'  &&  $data [ $pos ]  <=  '7' )
								$result		.=  $data [ $pos ++ ] ;
						    }
						// Regular character escapes
						else
		   					$result 	.=  $nch . $data [ $pos ++ ] ;
					    }
		   			else if  ( $nch  ==  ')' )
		   			   {
		   				$result 	.=  ')' ;
		   				break ;
		   			    }
		   			else
		   				$result 	.=  $nch ;
		   		   }

		   		return ( [ $result, $pos ] ) ;

			// A construction of the form : "<< something >>", or a unicode character
		   	case 	'<' :
		   		if (  isset ( $data [ $index + 1 ] )  &&  $data [ $index + 1 ]  ==  '<' )
		   		   {
		   		   	$pos 	=  strpos ( $data, '>>', $index + 1 ) ;

		   			if  ( $pos  ===  false )
		   				return ( false ) ;

		   			$token 	=  substr ( $data, $index, $pos - $index + 2 ) ;

		   			return ( [ $token, $pos + 2 ] ) ;
		   		    }
		   		else if  ( isset ( $data [ $index + 1 ] )  &&  ! ctype_xdigit ( $data [ $index + 1 ] ) )
		   		   {
		   		   	$pos 	=  strpos ( $data, '>', $index + 1 ) ;

		   			if  ( $pos  ===  false )
		   				return ( false ) ;

		   			$token 	=  substr ( $data, $index, $pos - $index + 2 ) ;

		   			return ( [ $token, $pos + 1 ] ) ;
		   		   }
		   		else
		   		   {
		   		   	$token 	=  '<' ;
		   		   	$pos 	=  $index + 1 ;

		   		   	while  ( $pos  <  $data_length  &&  ctype_xdigit ( $data [ $pos ] ) )
		   		   		$token 	.=  $data [ $pos ++ ] ;

		   		   	if  ( $pos  <  $data_length  &&  $data[ $pos ]  ==  '>' )
		   		   		return ( [ $token . '>', $pos + 1 ] ) ;
		   		   	else
		   		   		return ( false ) ;
		   		    }

			// Tick character : consider it as a keyword, in the same way as the "TJ" or "Tj" keywords
		   	case 	"'" :
		   		return ( [ "'", $index + 1 ] ) ;

			// Other cases : this may be either a floating-point number or a keyword
		   	default :
		   		$index ++ ;
		   		$value 	=  $ch ;

		   		if ( ctype_digit ( $ch )  ||  $ch  ==  '-'  ||  $ch  ==  '+' )
		   		   {
		   			while  ( $index  <  $data_length  &&
		   					( ctype_digit ( $data [ $index ] )  ||  $data [ $index ]  ==  '.' ) )
		   				$value 	.=  $data [ $index ++ ] ;
		   		    }
		   		else if  ( ctype_alpha ( $ch )  ||  $ch  ==  '/' )
		   		   {
					while  ( $index  <  $data_length  &&  ( ctype_alnum ( $data [ $index ] )  ||  $data [ $index ]  ==  '*'  ||  $data [ $index ]  ==  '-' ) )
						$value 	.=  $data [ $index ++ ] ;
		   		    }

		   		return ( [ $value, $index ] ) ;
		    }
	    }


	// __extract_chars_from_array -
	//	Extracts characters enclosed either within parentheses (character codes) or angle brackets (hex value)
	//	from an array.
	//	Example :
	//
	//		[<0D>-40<02>-36<03>-39<0E>-36<0F>-36<0B>-37<10>-37<10>-35(abc)]
	//
	// 	will return an array having the following entries :
	//
	//		<0D>, <02>, <03>, <0E>, <0F>, <0B>, <10>, <10>, (abc)
	private function  __extract_chars_from_array ( $array )
	   {
		$length 	=  strlen ( $array ) - 1 ;
		$result 	=  [] ;
		$offsets	=  [] ; 

		for  ( $i = 1 ; $i  <  $length ; $i ++ )	// Start with character right after the opening bracket
		   {
		   	$ch 	=  $array [$i] ;

			if  ( $ch  ==  '(' )
				$endch 	=  ')' ;
			else if  ( $ch  ==  '<' )
				$endch 	=  '>' ;
			else
			   {
				$value	=  '' ;

				while  ( $i  <  $length  &&  ( ctype_digit ( $array [$i] )  ||  $array [$i]  ==  '-'  ||  $array [$i]  ==  '+' ) )
					$value	.=  $array [$i++] ;

				$offsets []	=  ( integer ) $value ;

				if  ( $value  !==  '' )
					$i -- ;

				continue ;
			    }

			$char 	=  $ch ;
			$i ++ ;

			while  ( $i  <  $length  &&  $array [$i]  !=  $endch )
			   {
			   	if  ( $array [$i]  ==  '\\' )
			   		$char 	.=  '\\' . $array [++$i] ;
				else
				   {
					$char 	.=  $array [$i] ;

					if  ( $array [$i]  ==  $endch )
						break ;
				    }

				$i ++ ;
			   }

			$result [] 	 =  $char . $endch ;
		    }

		return ( [ $result, $offsets ] ) ;
	    }


	private function  __get_character_padding ( $char_offset )
	   {
		if  ( $char_offset  <=  - $this -> MinSpaceWidth )
		   {
			if  ( $this -> Options  &&  self::PDFOPT_REPEAT_SEPARATOR )
			   {
				// If the MinSpaceWidth property is less than 1000 (text units), consider it has the value 1000
				// so that an exuberant number of spaces will not be repeated
				$space_width	=  ( $this -> MinSpaceWidth  <  1000 ) ?  1000 :  $this -> MinSpaceWidth ;

				$repeat_count	=  abs ( round ( $char_offset / $space_width, 0 ) ) ;

				if  ( $repeat_count )
					$padding	=  str_repeat ( $this -> Separator, $repeat_count ) ;
				else
					$padding	=  $this -> Separator ;
				}
			else 
				$padding	=  $this -> Separator ;

			return ( utf8_encode ( $this -> Unescape ( $padding ) ) ) ;
		    }
		else
			return ( '' ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        Unescape - Processes escape sequences from the specified string.

	    PROTOTYPE
	        $value	=  $this -> Unescape ( $text ) ;

	    DESCRIPTION
	        Processes escape sequences within the specified text. The recognized escape sequences are like the
		C-language ones : \b (backspace), \f (form feed), \r (carriage return), \n (newline), \t (tab).
		All other characters prefixed by "\" are returned as is.

	    PARAMETERS
	        $text (string) -
	                Text to be unescaped.

	    RETURN VALUE
	        Returns the unescaped value of $text.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function   Unescape ( $text )
	   {
		$length 	=  strlen ( $text ) ;
		$result 	=  '' ;

		for  ( $i = 0 ; $i  <  $length ; $i ++ )
		   {
		   	$ch 	=  $text [$i] ;

			if  ( $ch  ==  '\\'  &&  isset ( $text [$i+1] ) )
			   {
				$nch 	=  $text [++$i] ;

				switch  ( $nch )
				   {
				   	case 	'b' 	:  $result .=  "\b" ; break ;
				   	case 	't' 	:  $result .=  "\t" ; break ;
				   	case 	'f' 	:  $result .=  "\f" ; break ;
				   	case 	'r' 	:  $result .=  "\r" ; break ;
				   	case 	'n' 	:  $result .=  "\n" ; break ;
				   	default 	:  $result .=  $nch ;
				    }
			    }
			else
				$result 	.=  $ch ;
		    }

		return ( $result ) ;
	    }
    }


/*==============================================================================================================

    PdfTexterFontTable class -
        The PdfTexterFontTable class is not supposed to be used outside the context of the PdfToText class.
	Its purposes are to hold a list of font definitions taken from a pdf document, along with their
	associated character mapping tables, if any.
	This is why no provision has been made to design this class a a general purpose class ; its utility
	exists only in the scope of the PdfToText class.

  ==============================================================================================================*/
class 	PdfTexterFontTable 	extends PdfObjectBase
   {
	// Font table
	private		$Fonts		=  [] ;
	// Font mapping between a font number and an object number
	private 	$FontMap 	=  [] ;

	// Constructor -
	//	Well, does not do anything special
	public function  __construct ( )
	   {
		parent::__construct ( ) ;
	    }


	// Add -
	//	Adds the current font declaration to the font table. Handles special cases where font id is not
	//	given by the object id, but rather by <</Rx...>> constructs
	public function  Add ( $object_id, $font_definition )
	   {
		if  ( PdfToText::$DEBUG )
		   {
	   		echo "----------------------------------- FONT #$object_id\n" ;
			echo $font_definition ;
		    }

	   	if  ( preg_match ( '#<< \s* (?P<rscdefs> /R\d+ .*) >>#ix', $font_definition, $match ) )
		   {
			$resource_definitions	=  $match [ 'rscdefs' ] ;

			preg_match_all ( '#/R (?P<font_id> \d+) #ix', $resource_definitions, $id_matches ) ;
			preg_match_all ( '#/ToUnicode \s* (?P<cmap_id> \d+)#ix', $resource_definitions, $cmap_matches ) ;

			$count		=  count ( $id_matches [ 'font_id' ] ) ;

			for  ( $i = 0 ;  $i  <  $count ; $i ++ )
			   {
				$font_id	=  $id_matches   [ 'font_id' ] [$i] ;
				$cmap_id	=  $cmap_matches [ 'cmap_id' ] [$i] ;

				$this -> Fonts [ $font_id ]	=  new  PdfTexterFont ( $font_id, $cmap_id ) ;
			    }
		    }
		else if  ( preg_match ( '#/ToUnicode \s* (?P<cmap> \d+)#ix', $font_definition, $match ) )
			$cmap_id	=  $match [ 'cmap' ] ;
		else if  ( preg_match ( '#/Encoding \s+ (?P<cmap> \d+) \s+ \d+ #ix', $font_definition, $match ) )
			$cmap_id 	=  $match [ 'cmap' ] ;
		else
			$cmap_id 	=  0 ;

		$this -> Fonts [ $object_id ]	=  new  PdfTexterFont ( $object_id, $cmap_id ) ;
	    }


	// AddFontMap -
	//	Process things like :
	//		<</F1 26 0 R/F2 22 0 R/F3 18 0 R>>
	//	which maps font 1 (when specified with the /Fx instruction) to object 26,
	//	2 to object 22 and 3 to object 18, respectively, in the above example.
	//	Found also a strange way of specifying a font mapping :
	//		<</f-0-0 5 0 R etc.
	public function  AddFontMap ( $object_id, $object_data )
	   {
		if  ( preg_match_all ( '#/F(?P<font> \d+) \s+ (?P<object> \d+)#x', $object_data, $matches ) )
		   {
		   	for ( $i = 0, $count = count ( $matches [ 'font' ] ) ; $i  <  $count ; $i ++ )
		   		$this -> FontMap [ $matches [ 'font' ] [$i] ] 	=  $matches [ 'object' ] [$i] ;
		    }
		else if  ( preg_match_all ( '#/f-(?P<font> \d+ - \d+) \s+ (?P<object> \d+)#x', $object_data, $matches ) )
		   {
		   	for ( $i = 0, $count = count ( $matches [ 'font' ] ) ; $i  <  $count ; $i ++ )
		   		$this -> FontMap [ $matches [ 'font' ] [$i] ] 	=  $matches [ 'object' ] [$i] ;
		    }
	    }


	// AddCharacterMap -
	//	Associates a character map to a font declaration that referenced it.
	public function  AddCharacterMap ( $cmap )
	   {
		foreach  ( $this -> Fonts  as  $font )
		   {
			if  ( $font -> CharacterMapId  ==  $cmap -> ObjectId )
			   {
				$font -> CharacterMap	=  $cmap ;

				return ( true ) ;
			    }
		    }

		return ( false ) ;
	    }


	// GetFontByMapId -
	//	Returns the font id (object id) associated to the specified mapped id.
	public function  GetFontByMapId ( $id )
	   {
		if  ( isset ( $this -> FontMap [ $id ] ) )
			return ( $this -> FontMap [ $id ] ) ;
		else
			return ( -1 ) ;
	    }

	// IsMapped -
	//	Checks if the specified font has an associated character map.
	public function  IsMapped ( $font )
	   {
		// For text contents that did not specify a font using the /Rx instruction,
		// use the first declared font as the default font
		if  ( $font  ==  -1 )
		   {
			reset ( $this -> Fonts ) ;
			$font 	=  key ( $this -> Fonts ) ;
		    }

		return ( isset ( $this -> Fonts [ $font ] )  &&
				$this -> Fonts [ $font ] -> CharacterMap ) ;
	    }


	// GetMapWidth -
	//	Returns the number of hex digits needed to represent a character in the specified font.
	public function  GetMapWidth ( $font )
	   {
		// For text contents that did not specify a font using the /Rx instruction,
		// use the first declared font as the default font
		if  ( $font  ==  -1 )
		   {
			reset ( $this -> Fonts ) ;
			$font 	=  key ( $this -> Fonts ) ;
		    }

		if  ( isset ( $this -> Fonts [ $font ] )  &&  $this -> Fonts [ $font ] -> CharacterMap )
		   {
			$width 	=  $this -> Fonts [ $font ] -> CharacterMap -> HexCharWidth ;

			if  ( $width )
				return ( $width ) ;
		    }

		return ( 4 ) ; 		// Should never happen!
	    }


	// MapCharacter -
	//	Returns the character associated to the specified one.
	public function  MapCharacter ( $font, $ch )
	   {
		// For text contents that did not specify a font using the /Rx instruction,
		// use the first declared font as the default font
		if  ( $font  ==  -1 )
		   {
			reset ( $this -> Fonts ) ;
			$font 	=  key ( $this -> Fonts ) ;
		    }

		if  ( isset  ( $this -> Fonts [ $font ] ) )
			return ( $this -> Fonts [ $font ] -> MapCharacter ( $ch ) ) ;
		else
			return ( utf8_encode ( chr ( $ch ) ) ) ;
	    }
    }



/*==============================================================================================================

    PdfTexterFont class -
        The PdfTexterFont class is not supposed to be used outside the context of the PdfToText class.
	It holds an optional character mapping table associted with this font.
	No provision has been made to design this class a a general purpose class ; its utility exists only in
	the scope of the PdfToText class.

  ==============================================================================================================*/
class  PdfTexterFont		extends PdfObjectBase
   {
	// Font resource id (may be an object id, overridden by <</Rx...>> constructs
	public		$Id ;
	// Character map id, specified by the /ToUnicode flag
	public		$CharacterMapId ;
	// Optional character map, that may be set by the PdfToText::Load method just before processing text drawinf blocks
	public		$CharacterMap		=  null ;


	// Constructor -
	//	Builds a PdfTexterFont object, using its resource id and optional character map id.
	public function  __construct ( $resource_id, $cmap_id )
	   {
		parent::__construct ( ) ;
		$this -> Id		=  $resource_id ;
		$this -> CharacterMapId	=  $cmap_id ;
	    }


	// MapCharacter -
	//	Returns the substitution string value for the specified character, if the current font has an
	//	associated character map, or the original character encoded in utf8, if not.
	public function  MapCharacter ( $ch )
	   {
		if  ( $this -> CharacterMap )
			return ( $this -> CharacterMap [ $ch ] ) ;
		else
			return ( chr ( $ch ) ) ;
	    }
    }


/*==============================================================================================================

    PdfTexterCharacterMap -
        The PdfTexterFont class is not supposed to be used outside the context of the PdfToText class.
	Describes a character map.
	No provision has been made to design this class a a general purpose class ; its utility exists only in
	the scope of the PdfToText class.

  ==============================================================================================================*/
abstract class	PdfTexterCharacterMap	extends		PdfObjectBase
					implements	\ArrayAccess, \Countable
   {
	// Object id of the character map
	public		$ObjectId ;
	// Number of hex digits in a character represented in hexadecimal notation
	public 		$HexCharWidth ;



	public function  __construct ( $object_id )
	   {
		parent::__construct ( ) ;
		$this -> ObjectId	=  $object_id ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    CreateInstance -
	        Creates a PdfTexterCharacterMap instance of the correct type.

	 *-------------------------------------------------------------------------------------------------------------*/
	public static function  CreateInstance ( $object_id, $definitions )
	   {
		if  ( stripos ( $definitions, 'begincmap'    )  !==  false  ||  
		      stripos ( $definitions, 'beginbfchar'  )  !==  false  ||
		      stripos ( $definitions, 'beginbfrange' )  !==  false )
			return ( new PdfTexterUnicodeMap ( $object_id, $definitions ) ) ;
		else if  ( stripos ( $definitions, '/Differences' )  !==  false )
			return ( new PdfTexterEncodingMap ( $object_id, $definitions ) ) ;
		else
			return ( false ) ;
	    }



	/*--------------------------------------------------------------------------------------------------------------

	        Interface implementations.

	 *-------------------------------------------------------------------------------------------------------------*/
	abstract function  count 		( ) ;
	abstract function  offsetExists 	( $offset ) ;
	abstract function  offsetGet 		( $offset ) ;

	public function  offsetSet ( $offset, $value )
	   { error ( new PdfToTextException ( "Unsupported operation." ) ) ; }

	public function  offsetUnset ( $offset )
	   { error ( new PdfToTextException ( "Unsupported operation." ) ) ; }
    }



/*==============================================================================================================

    PdfTexterUnicodeMap -
        A class for fonts having a character map specified with the /ToUnicode parameter.

  ==============================================================================================================*/
class  PdfTexterUnicodeMap 	extends 	PdfTexterCharacterMap
    {
	// Id of the character map (specified by the /Rx flag)
	public		$Id	;
	// Character substitution table
	protected	$Map			=  [] ;


	// Constructor -
	//	Analyzes the text contents of a CMAP and extracts mappings from the beginbfchar/endbfchar and
	//	beginbfrange/endbfrange constructs.
	public function  __construct ( $object_id, $definitions )
	   {
		parent::__construct ( $object_id ) ;

		if  ( PdfToText::$DEBUG )
		   {
	   		echo "----------------------------------- UNICODE CMAP #$object_id\n" ;
			echo $definitions;
		    }

		// Retrieve the cmap id, if any
		preg_match ( '# /CMapName \s* /R (?P<num> \d+) #ix', $definitions, $match ) ;
		$this -> Id 		=  isset ( $match [ 'num' ] ) ?  $match [ 'num' ] : -1 ;

		// Get the codespace range, which will give us the width of a character specified in hexadecimal notation
		preg_match ( '# begincodespacerange \s+ <\s* (?P<low> [0-9a-f]+) \s*> \s* <\s* (?P<high> [0-9a-f]+) \s*> \s*endcodespacerange #ix', $definitions, $match ) ;

		$this -> HexCharWidth 	=  max ( strlen ( $match [ 'low' ] ), strlen ( $match [ 'high' ] ) ) ;

		// Process beginbfchar/endbfchar constructs
		if  ( preg_match_all ( '/ beginbfchar \s* (?P<chars> .*?) endbfchar /imsx', $definitions, $char_matches ) )
		    {
		    	foreach  ( $char_matches [ 'chars' ]  as  $char_list )
		    	   {
				// Don't believe that the contents between beginbfchar/endbfchar are separated by line breaks !
				// I have met one example where everything was put on the same line
				preg_match_all ( '/ < \s* (?P<char> [0-9a-f]+) \s* > /imx', $char_list, $code_matches ) ;

				for  ( $i = 0, $count = count ( $code_matches [ 'char' ] ) ; $i  <  $count ; $i += 2 )
				   {
					   $src		=  hexdec ( $code_matches [ 'char' ] [ $i ] ) ;
					   $chunks	=  str_split ( $code_matches [ 'char' ] [ $i + 1 ], $this -> HexCharWidth ) ;
					   $dst		=  [] ;

					   foreach  ( $chunks  as  $chunk )
						$dst []		=  hexdec ( $chunk ) ;

					   $this -> Map [ $src ]	=  $dst ;
				    }
		    	    }
		     }

		// Process beginbfrange/endbfrange constructs
		if  ( preg_match_all ( '/ beginbfrange \s* (?P<ranges> .*?) endbfrange /imsx', $definitions, $range_matches ) )
		   {
			foreach  ( $range_matches [ 'ranges' ]  as  $range_list )
			   {
			   	$ranges 	=  explode ( "\n", trim ( $range_list ) ) ;

				// Loop through each range definition
				foreach  ( $ranges  as  $range )
				   {
					// Normal form :
					//	<from><to><start>
					//	Generates mappings from start+from to start+to.
					if  ( preg_match ( '/ <\s* (?P<from> [0-9a-f]+) \s*> \s* <\s* (?P<to> [0-9a-f]+) \s* > \s* <\s* (?P<subst> [0-9a-f]+) \s* > /imx',
									$range, $range_match ) )
					   {
						$from 		=  hexdec ( $range_match [ 'from'  ] ) ;
						$to 		=  hexdec ( $range_match [ 'to'    ] ) ;
						$subst 		=  hexdec ( $range_match [ 'subst' ] ) ;

						for  ( $i = $from, $count = 0 ; $i  <=  $to ; $i ++, $count ++ )
							$this -> Map [$i] 	=  [ $subst + $count ] ;
					    }
					// Array form :
					//	<from><to>[ value1, value2, ... valuen ]
					//	Generates mapping from "from" to "to" using the specified values. The value count
					//	between square brackets must be the same as to - from + 1.
				   	else if  ( preg_match ( '/ < \s* (?P<from> [0-9a-f]+) \s* > \s* < \s* (?P<to> [0-9a-f]+) \s* > \s* \[(?P<subst> .*?)\] /imx',
									$range, $range_match ) )
					   {
						$from 		=  hexdec ( $range_match [ 'from'  ] ) ;
						$to 		=  hexdec ( $range_match [ 'to'    ] ) ;
						$subst 		=  preg_split ( '/\s+/',  trim ( $range_match [ 'subst' ] ) ) ;

						for  ( $i = $from, $count = 0 ; $i  <=  $to ; $i ++, $count ++ )
							$this -> Map [$i] 	=  [ hexdec ( $subst [ $count ] ) ] ;
					    }
				   }
			    }
		    }
	     }


	/*--------------------------------------------------------------------------------------------------------------

	        Interface implementations.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  count ( )
	   { return ( count ( $this -> Map ) ) ; }


	public function  offsetExists ( $offset )
	   { return  ( isset ( $this -> Map [ $offset ] ) ) ; }


	public function  offsetGet ( $offset )
	   {
		if  ( isset ( $this -> Map [ $offset ] ) )
		   {
			$result		=  '' ;

			foreach  ( $this -> Map [ $offset ]  as  $code )
			   {
				// This is the horrible kludge to fix the issue about character maps of size x having substitutions
				// of size x+2, as described in the history entry for version 1.2.6
				if  ( $this -> HexCharWidth  ==  2  &&  ! $code )
					continue ;

		   		$entity 	 =  '&#' . sprintf ( "%d", $code ) .  ';' ;
		   		$result 	.=  mb_convert_encoding ( $entity, 'UTF-8', 'HTML-ENTITIES' ) ;
			    }

			return ( $result ) ;
		    }
		else
			return ( chr ( $offset ) ) ;
	    }
    }



/*==============================================================================================================

    PdfTexterEncodingMap -
        A class for fonts having a character map specified with the /Encoding parameter.

  ==============================================================================================================*/
class  PdfTexterEncodingMap 	extends  PdfTexterCharacterMap
   {
	// Possible encodings (there is a 5th one, MacExpertEncoding, but used for "expert fonts" ; no need to deal
	// with it here since we only want to extract text)
	// Note that the values of these constants are direct indices to the second dimension of the $Encodings table
	const 	PDF_STANDARD_ENCODING 		=  0 ;
	const 	PDF_MAC_ROMAN_ENCODING 		=  1 ;
	const 	PDF_WIN_ANSII_ENCODING 		=  2 ;
	const 	PDF_DOC_ENCODING 		=  3 ;

	// Correspondance between an encoding name and its corresponding character in the
	// following format : Standard, Mac, Windows, Pdf
	private static 		$Encodings 	=
	   [
		'A'			=>  [ 0101, 0101, 0101, 0101 ],
	   	'AE'			=>  [ 0341, 0256, 0306, 0306 ],
	   	'Aacute'		=>  [    0, 0347, 0301, 0301 ],
	   	'Acircumflex'		=>  [    0, 0345, 0302, 0302 ],
		'Adieresis'		=>  [    0, 0200, 0304, 0304 ],
		'Agrave'		=>  [    0, 0313, 0300, 0300 ],
		'Aring'			=>  [    0, 0201, 0305, 0305 ],
		'Atilde'		=>  [    0, 0314, 0303, 0303 ],
		'B'			=>  [ 0102, 0102, 0102, 0102 ],
	   	'C' 			=>  [ 0103, 0103, 0103, 0103 ],
		'Ccedilla'		=>  [    0, 0202, 0307, 0307 ],
		'D'			=>  [ 0104, 0104, 0104, 0104 ],
	   	'E' 			=>  [ 0105, 0105, 0105, 0105 ],
		'Eacute'		=>  [    0, 0203, 0311, 0311 ],
		'Ecircumflex'		=>  [    0, 0346, 0312, 0312 ],
		'Edieresis'		=>  [    0, 0350, 0313, 0313 ],
		'Egrave'		=>  [    0, 0351, 0310, 0310 ],
		'Eth' 			=>  [    0,    0, 0320, 0320 ],
		'Euro'			=>  [    0,    0, 0200, 0240 ],
		'F'			=>  [ 0106, 0106, 0106, 0106 ],
		'G'			=>  [ 0107, 0107, 0107, 0107 ],
		'H'			=>  [ 0110, 0110, 0110, 0110 ],
		'I'			=>  [ 0111, 0111, 0111, 0111 ],
	   	'Iacute'		=>  [    0, 0352, 0315, 0315 ],
	   	'Icircumflex'		=>  [    0, 0353, 0316, 0316 ],
		'Idieresis'		=>  [    0, 0354, 0317, 0317 ],
		'Igrave'		=>  [    0, 0355, 0314, 0314 ],
		'J'			=>  [ 0112, 0112, 0112, 0112 ],
		'K'			=>  [ 0113, 0113, 0113, 0113 ],
		'L'			=>  [ 0114, 0114, 0114, 0114 ],
		'Lslash'		=>  [ 0350,    0,    0, 0225 ],
		'M'			=>  [ 0115, 0115, 0115, 0115 ],
		'N'			=>  [ 0116, 0116, 0116, 0116 ],
		'Ntilde'		=>  [    0, 0204, 0321, 0321 ],
	   	'O'			=>  [ 0117, 0117, 0117, 0117 ],
		'OE' 			=>  [ 0352, 0316, 0214, 0226 ],
		'Oacute' 		=>  [    0, 0356, 0323, 0323 ],
		'Ocircumflex'		=>  [    0, 0357, 0324, 0324 ],
		'Odieresis'		=>  [    0, 0205, 0326, 0326 ],
		'Ograve'		=>  [    0, 0361, 0322, 0322 ],
		'Oslash' 		=>  [ 0351, 0257, 0330, 0330 ],
		'Otilde' 		=>  [    0, 0315, 0325, 0325 ],
	   	'P'			=>  [ 0120, 0120, 0120, 0120 ],
	   	'Q'			=>  [ 0121, 0121, 0121, 0121 ],
	   	'R'			=>  [ 0122, 0122, 0122, 0122 ],
	   	'S'			=>  [ 0123, 0123, 0123, 0123 ],
		'Scaron'		=>  [    0,    0, 0212, 0227 ],
		'T'			=>  [ 0124, 0124, 0124, 0124 ],
		'Thorn'			=>  [    0,    0, 0336, 0336 ],
		'U'			=>  [ 0125, 0125, 0125, 0125 ],
		'Uacute'		=>  [    0, 0362, 0332, 0332 ],
		'Ucircumflex'		=>  [    0, 0363, 0333, 0333 ],
		'Udieresis'		=>  [    0, 0206, 0334, 0334 ],
		'Ugrave'		=>  [    0, 0364, 0331, 0331 ],
		'V'			=>  [ 0126, 0126, 0126, 0126 ],
		'W'			=>  [ 0127, 0127, 0127, 0127 ],
		'X'			=>  [ 0130, 0130, 0130, 0130 ],
		'Y'			=>  [ 0131, 0131, 0131, 0131 ],
		'Yacute'		=>  [    0,    0, 0335, 0335 ],
		'Ydieresis'		=>  [    0, 0331, 0237, 0230 ],
		'Z'			=>  [ 0132, 0132, 0132, 0132 ],
	   	'Zcaron'		=>  [    0,    0, 0216, 0231 ],
		'a' 			=>  [ 0141, 0141, 0141, 0141 ],
		'aacute'		=>  [    0, 0207, 0341, 0341 ],
		'acircumflex'		=>  [    0, 0211, 0342, 0342 ],
		'acute'			=>  [ 0302, 0253, 0264, 0264 ],
		'adieresis'		=>  [    0, 0212, 0344, 0344 ],
		'ae'			=>  [ 0361, 0276, 0346, 0346 ],
		'agrave' 		=>  [    0, 0210, 0340, 0340 ],
		'ampersand' 		=>  [ 0046, 0046, 0046, 0046 ],
		'aring' 		=>  [    0, 0214, 0345, 0345 ],
		'asciicircum' 		=>  [ 0136, 0136, 0136, 0136 ],
		'asciitilde'		=>  [ 0176, 0176, 0176, 0176 ],
		'asterisk' 		=>  [ 0052, 0052, 0052, 0052 ],
		'at'			=>  [ 0100, 0100, 0100, 0100 ],
		'atilde'		=>  [    0, 0213, 0343, 0343 ],
		'b' 			=>  [ 0142, 0142, 0142, 0142 ],
		'backslash' 		=>  [ 0134, 0134, 0134, 0134 ],
		'bar' 			=>  [ 0174, 0174, 0174, 0174 ],
		'braceleft'		=>  [ 0173, 0173, 0173, 0173 ],
		'braceright' 		=>  [ 0175, 0175, 0175, 0175 ],
		'bracketleft' 		=>  [ 0133, 0133, 0133, 0133 ],
		'bracketright' 		=>  [ 0135, 0135, 0135, 0135 ],
		'breve'			=>  [ 0306, 0371,    0, 0030 ],
		'brokenbar' 		=>  [    0,    0, 0246, 0246 ],
		'bullet' 		=>  [ 0267, 0245, 0225, 0200 ],
		'c'			=>  [ 0143, 0143, 0143, 0143 ],
		'caron'			=>  [ 0317, 0377,    0, 0031 ],
		'ccedilla'		=>  [    0, 0215, 0347, 0347 ],
		'cedilla'		=>  [ 0313, 0374, 0270, 0270 ],
		'cent' 			=>  [ 0242, 0242, 0242, 0242 ],
		'circumflex' 		=>  [ 0303, 0366, 0210, 0032 ],
		'colon' 		=>  [ 0072, 0072, 0072, 0072 ],
		'comma'			=>  [ 0054, 0054, 0054, 0054 ],
		'copyright'		=>  [    0, 0251, 0251, 0251 ],
		'currency'		=>  [ 0250, 0333, 0244, 0244 ],
		'd'			=>  [ 0144, 0144, 0144, 0144 ],
		'dagger' 		=>  [ 0262, 0240, 0206, 0201 ],
		'daggerdbl' 		=>  [ 0263, 0340, 0207, 0202 ],
		'degree' 		=>  [    0, 0241, 0260, 0260 ],
		'dieresis'		=>  [ 0310, 0254, 0250, 0250 ],
		'divide' 		=>  [    0, 0326, 0367, 0367 ],
		'dollar' 		=>  [ 0044, 0044, 0044, 0044 ],
		'dotaccent' 		=>  [ 0307, 0372,    0, 0033 ],
		'dotlessi'		=>  [ 0365, 0365,    0, 0232 ],
		'e' 			=>  [ 0145, 0145, 0145, 0145 ],
		'eacute'		=>  [    0, 0216, 0351, 0351 ],
		'ecircumflex'		=>  [    0, 0220, 0352, 0352 ],
		'edieresis' 		=>  [    0, 0221, 0353, 0353 ],
		'egrave'		=>  [    0, 0217, 0350, 0350 ],
		'eight' 		=>  [ 0070, 0070, 0070, 0070 ],
		'ellipsis' 		=>  [ 0274, 0311, 0205, 0203 ],
		'emdash' 		=>  [ 0320, 0321, 0227, 0204 ],
		'endash' 		=>  [ 0261, 0320, 0226, 0205 ],
		'equal' 		=>  [ 0075, 0075, 0075, 0075 ],
		'eth'			=>  [    0,    0, 0360, 0360 ],
		'exclam' 		=>  [ 0041, 0041, 0041, 0041 ],
		'exclamdown' 		=>  [ 0241, 0301, 0241, 0241 ],
		'f' 			=>  [ 0146, 0146, 0146, 0146 ],
		'fi' 			=>  [ 0256, 0336,    0, 0223 ],
		'five' 			=>  [ 0065, 0065, 0065, 0065 ],
		'fl' 			=>  [ 0257, 0337,    0, 0224 ],
		'florin' 		=>  [ 0246, 0304, 0203, 0206 ],
		'four'			=>  [ 0064, 0064, 0064, 0064 ],
		'fraction'		=>  [ 0244, 0332,    0, 0207 ],
		'g' 			=>  [ 0147, 0147, 0147, 0147 ],
		'germandbls'		=>  [ 0373, 0247, 0337, 0337 ],
		'grave' 		=>  [ 0301, 0140, 0140, 0140 ],
		'greater' 		=>  [ 0076, 0076, 0076, 0076 ],
		'guillemotleft'		=>  [ 0253, 0307, 0253, 0253 ],
		'guillemotright' 	=>  [ 0273, 0310, 0273, 0273 ],
		'guilsinglleft'		=>  [ 0254, 0334, 0213, 0210 ],
		'guilsinglright'	=>  [ 0255, 0335, 0233, 0211 ],
		'h'			=>  [ 0150, 0150, 0150, 0150 ],
		'hungarumlaut'		=>  [ 0315, 0375,    0, 0034 ],
		'hyphen' 		=>  [ 0055, 0055, 0055, 0055 ],
		'i' 			=>  [ 0151, 0151, 0151, 0151 ],
		'iacute'		=>  [    0, 0222, 0355, 0355 ],
		'icircumflex' 		=>  [    0, 0224, 0356, 0356 ],
		'idieresis'		=>  [    0, 0225, 0357, 0357 ],
		'igrave' 		=>  [    0, 0223, 0354, 0354 ],
		'j' 			=>  [ 0152, 0152, 0152, 0152 ],
		'k' 			=>  [ 0153, 0153, 0153, 0153 ],
		'l' 			=>  [ 0154, 0154, 0154, 0154 ],
		'less'			=>  [ 0074, 0074, 0074, 0074 ],
		'logicalnot' 		=>  [    0, 0302, 0254, 0254 ],
		'lslash'		=>  [ 0370,    0,    0, 0233 ],
		'm'			=>  [ 0155, 0155, 0155, 0155 ],
		'macron'		=>  [ 0305, 0370, 0257, 0257 ],
		'minus' 		=>  [    0,    0,    0, 0212 ],
		'mu' 			=>  [    0, 0265, 0265, 0265 ],
		'multiply'		=>  [    0,    0, 0327, 0327 ],
		'n' 			=>  [ 0156, 0156, 0156, 0156 ],
		'nine' 			=>  [ 0071, 0071, 0071, 0071 ],
		'ntilde' 		=>  [    0, 0226, 0361, 0361 ],
		'numbersign' 		=>  [ 0043, 0043, 0043, 0043 ],
		'o'			=>  [ 0157, 0157, 0157, 0157 ],
		'oacute' 		=>  [    0, 0227, 0363, 0363 ],
		'ocircumflex' 		=>  [    0, 0231, 0364, 0364 ],
		'odieresis'		=>  [    0, 0232, 0366, 0366 ],
		'oe' 			=>  [ 0372, 0317, 0234, 0234 ],
		'ogonek' 		=>  [ 0316, 0376,    0, 0035 ],
		'ograve'		=>  [    0, 0230, 0362, 0362 ],
		'one' 			=>  [ 0061, 0061, 0061, 0061 ],
		'onehalf' 		=>  [    0,    0, 0275, 0275 ],
		'onequarter' 		=>  [    0,    0, 0274, 0274 ],
		'onesuperior'		=>  [    0,    0, 0271, 0271 ],
		'ordfeminine' 		=>  [ 0343, 0273, 0252, 0252 ],
		'ordmasculine' 		=>  [ 0353, 0274, 0272, 0272 ],
		'oslash'		=>  [ 0371, 0277, 0370, 0370 ],
		'otilde' 		=>  [    0, 0233, 0365, 0365 ],
		'p'			=>  [ 0160, 0160, 0160, 0160 ],
		'paragraph' 		=>  [ 0266, 0246, 0266, 0266 ],
		'parenleft' 		=>  [ 0050, 0050, 0050, 0050 ],
		'parenright'		=>  [ 0051, 0051, 0051, 0051 ],
		'percent' 		=>  [ 0045, 0045, 0045, 0045 ],
		'period' 		=>  [ 0056, 0056, 0056, 0056 ],
		'periodcentered'	=>  [ 0264, 0341, 0267, 0267 ],
		'perthousand' 		=>  [ 0275, 0344, 0211, 0213 ],
		'plus' 			=>  [ 0053, 0053, 0053, 0053 ],
		'plusminus' 		=>  [    0, 0261, 0261, 0261 ],
		'q' 			=>  [ 0161, 0161, 0161, 0161 ],
		'question' 		=>  [ 0077, 0077, 0077, 0077 ],
		'questiondown' 		=>  [ 0277, 0300, 0277, 0277 ],
		'quotedbl' 		=>  [ 0042, 0042, 0042, 0042 ],
		'quotedblbase' 		=>  [ 0271, 0343, 0204, 0214 ],
		'quotedblleft'		=>  [ 0252, 0322, 0223, 0215 ],
		'quotedblright'		=>  [ 0272, 0323, 0224, 0216 ],
		'quoteleft' 		=>  [ 0140, 0324, 0221, 0217 ],
		'quoteright'		=>  [ 0047, 0325, 0222, 0220 ],
		'quotesinglbase'	=>  [ 0270, 0342, 0202, 0221 ],
		'quotesingle'		=>  [ 0251, 0047, 0047, 0047 ],
		'r'			=>  [ 0162, 0162, 0162, 0162 ],
		'registered' 		=>  [    0, 0250, 0256, 0256 ],
		'ring' 			=>  [ 0312, 0373,    0, 0036 ],
		's'			=>  [ 0163, 0163, 0163, 0163 ],
		'scaron'		=>  [    0,    0, 0232, 0235 ],
		'section'		=>  [ 0247, 0244, 0247, 0247 ],
		'semicolon' 		=>  [ 0073, 0073, 0073, 0073 ],
		'seven' 		=>  [ 0067, 0067, 0067, 0067 ],
		'six' 			=>  [ 0066, 0066, 0066, 0066 ],
		'slash' 		=>  [ 0057, 0057, 0057, 0057 ],
		'space' 		=>  [ 0040, 0040, 0040, 0040 ],
		'sterling'		=>  [ 0243, 0243, 0243, 0243 ],
		't'			=>  [ 0164, 0164, 0164, 0164 ],
		'thorn' 		=>  [    0,    0, 0376, 0376 ],
		'three'			=>  [ 0063, 0063, 0063, 0063 ],
		'threequarters'		=>  [    0,    0, 0276, 0276 ],
		'threesuperior' 	=>  [    0,    0, 0263, 0263 ],
		'tilde'			=>  [ 0304, 0367, 0230, 0037 ],
		'trademark' 		=>  [    0, 0252, 0231, 0222 ],
		'two' 			=>  [ 0062, 0062, 0062, 0062 ],
		'twosuperior'		=>  [    0,    0, 0262, 0262 ],
		'u' 			=>  [ 0165, 0165, 0165, 0165 ],
		'uacute'		=>  [    0, 0234, 0372, 0372 ],
		'ucircumflex' 		=>  [    0, 0236, 0373, 0373 ],
		'udieresis'		=>  [    0, 0237, 0374, 0374 ],
		'ugrave' 		=>  [    0, 0235, 0371, 0371 ],
		'underscore' 		=>  [ 0137, 0137, 0137, 0137 ],
		'v' 			=>  [ 0166, 0166, 0166, 0166 ],
		'w' 			=>  [ 0167, 0167, 0167, 0167 ],
		'x' 			=>  [ 0170, 0170, 0170, 0170 ],
		'y' 			=>  [ 0171, 0171, 0171, 0171 ],
		'yacute' 		=>  [    0,    0, 0375, 0375 ],
		'ydieresis' 		=>  [    0, 0330, 0377, 0377 ],
		'yen' 			=>  [ 0245, 0264, 0245, 0245 ],
		'z'			=>  [ 0172, 0172, 0172, 0172 ],
		'zcaron' 		=>  [    0,    0, 0236, 0236 ],
		'zero' 			=>  [ 0060, 0060, 0060, 0060 ]
	   ] ;


	// Encoding type (one of the PDF_*_ENCODING constants)
	public 		$Encoding ;
	// Differences array (a character substitution table to the standard encodings)
	protected 	$Map 		=  [] ;


   	// Constructor -
	//	Analyzes the text contents of a CMAP and extracts mappings from the beginbfchar/endbfchar and
	//	beginbfrange/endbfrange constructs.
	public function  __construct ( $object_id, $definitions )
	   {
		parent::__construct ( $object_id ) ;

		$this -> HexCharWidth	=  2 ;

		if  ( PdfToText::$DEBUG )
		   {
	   		echo "----------------------------------- ENCODING CMAP #$object_id\n" ;
			echo $definitions;
		    }

		// Retrieve text encoding
		preg_match ( '# / (?P<encoding> (WinAnsiEncoding) | (PDFDocEncoding) | (MacRomanEncoding) | (StandardEncoding) ) #ix',
				$definitions, $encoding_match ) ;

		if ( ! isset ( $encoding_match [ 'encoding' ] ) )
			$encoding_match [ 'encoding' ]	=  'WinAnsiEncoding' ;

		switch ( strtolower ( $encoding_match [ 'encoding' ] ) )
		   {
		   	case 	'pdfdocencoding' 	:  $this -> Encoding	=  self::PDF_DOC_ENCODING 	; break ;
		   	case 	'macromanencoding' 	:  $this -> Encoding 	=  self::PDF_MAC_ROMAN_ENCODING ; break ;
		   	case 	'standardencoding' 	:  $this -> Encoding 	=  self::PDF_STANDARD_ENCODING 	; break ;
		   	case 	'winansiencoding' 	:
		   	default 		 	:  $this -> Encoding 	=  self::PDF_WIN_ANSII_ENCODING	;
		    }

		// Build a virgin character map using the detected encoding
		foreach  ( self::$Encodings  as  $code_array )
		   {
			$char 			=  $code_array [ $this -> Encoding ] ;
			$this -> Map [ $char ] 	=  $char ;
		    }

		// Extract the Differences array
	   	preg_match ( '/ \[ (?P<contents> [^\]]*)  \] /x', $definitions, $match ) ;
		$data 		=  trim ( preg_replace ( '/(\d+)/', '/$1', $match [ 'contents' ] ) ) ;
		$items 		=  explode ( '/', $data ) ;
		array_shift ( $items ) ;

		$index 		=  0 ;

		for  ( $i = 0, $item_count = count ( $items ) ; $i  <  $item_count ; $i ++ )
		   {
		   	$item 		=  trim ( $items [$i] ) ;

		   	// Integer value  : index of next character in map
			if  ( is_numeric ( $item ) )
				$index 	=  ( integer ) $item ;
			// String value : a character name, as defined by Adobe
			else
			   {
			   	// Keyword (character name) exists in the encoding table
				if  ( isset ( self::$Encodings [ $item ] ) )
					$this -> Map [ $index ] 	=  self::$Encodings [ $item ] [ $this -> Encoding ];
				// Otherwise, put a quotation mark instead
				else
					$this -> Map [ $index ] 	=  '?' ;

				$index ++ ;
			    }
		    }
	    }


	/*--------------------------------------------------------------------------------------------------------------

	        Interface implementations.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  count ( )
	   { return ( count ( $this -> Map ) ) ; }


	public function  offsetExists ( $offset )
	   { return ( isset ( $this -> Map [ $offset ] ) ) ; }


	public function  offsetGet ( $offset )
	   {
		if  ( isset ( $this -> Map [ $offset ] ) )
		   {
			return ( chr ( $this -> Map [ $offset ] ) ) ;
		    }
		else
			return ( chr ( $offset ) ) ;
	    }
    }


/*==============================================================================================================

    PdfTexterPageMap -
        A class for detecting page objects mappings and retrieving page number for a specified object.
	There is a quadruple level of indirection here :

	- The first level contains a /Type /Catalog parameter, with a /Pages one that references an object which
	  contains a /Count and /Kids. I don't know yet if the /Pages parameter can reference more than one
	  object using the array notation. However, the class is designed to handle such situations.
	- The object containing the /Kids parameter references objects who, in turn, lists the objects contained
	  into one single page.
	- Each object referenced in /Kids has a /Type/Page parameter, together with /Contents, which lists the
	  objects of the current page.

	Object references are of the form : "x y R", where "x" is the object number.

	Of course, anything can be in any order, otherwise it would not be funny ! Consider the following 
	example :

		(1) 5 0 obj
			<< ... /Pages 1 0 R ... >>
		    endobj

		(2) 1 0 obj
			<< ... /Count 1 /Kids[6 0 R] ... /Type/Pages ... >>
		    endobj

		(3)  6 0 obj
			<< ... /Type/Page ... /Parent 1 0 R ... /Contents [10 0 R 11 0 R ... x 0 R]
		     endobj

	Object #5 says that object #1 contains the list of page contents (in this example, there is only one page,
	referenced by object #6).
	Object #6 says that the objects #10, #11 through #x are contained into the same page.
	The quadruple indirection comes when you are handling one of the objects referenced in object #6 and you
	need to retrieve their page number...

	Of course, you cannot rely on the fact that all objects appear in logical order.

	And, of course #2, there may be no page catalog at all ! in such cases, objects containing drawing 
	instructions will have to be considered as a single page, whose number will be sequential.

	And, of course #3, as this is the case with the official PDF 1.7 Reference from Adobe, there can be a
	reference to a non-existing object which was meant to contain the /Kids parameter (!). In this case,
	taking the ordinal number of objects of type (3) gives the page number minus one.

	One mystery is that the PDF 1.7 Reference file contains 1310 pages but only 1309 are recognized here...

  ==============================================================================================================*/
class  PdfTexterPageMap		extends		PdfObjectBase	
				implements	\ArrayAccess, \Countable
   {
	// Page catalog, ie the id(s) of object(s) giving the list of objects describing pages (/Type/Catalog together with /Pages referencing an object)
	protected	$PageCatalog		=  [] ;
	// List of object listing the objects grouped per page (/Count and /Kids parameters)
	protected	$PageObjects		=  [] ;
	// List of objects grouped into one page (/Type/Page parameter, with /Contents)
	protected 	$PageContentObjects	=  [] ;
	// Once everything has been collected in the pdf file, the MapPages() method must be called to map object ids to page numbers
	protected	$PageNumbers		=  [] ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    CONSTRUCTOR
		Creates a PdfTexterPageMap object. Actually, nothing significant is perfomed here, as this class' goal
		is to be used internally by PdfTexter.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( )
	   {
		parent::__construct ( ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        Peek - Peeks page information from a pdf object.
	
	    PROTOTYPE
	        $pagemap -> Peek ( ) ;
	
	    DESCRIPTION
	        Retrieves page information which can be of type (1), (2) or (3), as described in the class comments.
	
	    PARAMETERS
	        $object_id (integer) -
	                Id of the current pdf object.

		$object_data (string) -
			Pdf object contents.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  Peek ( $object_id, $object_data )
	   {
		// Page catalog (/Type/Catalog and /Pages x 0 R)
		if  ( preg_match ( '#/Type \s* /Catalog#ix', $object_data )  &&  $this -> GetObjectReferences ( $object_id, $object_data, '/Pages', $references ) )
		   {
			$this -> PageCatalog	=  array_merge ( $this -> PageCatalog, $references ) ;
		    }
		// Object listing the object numbers that give the list of objects contained in a single page (/Types/Pages and /Count x /Kids[x1 0 R ... xn 0 R]
		else if  ( preg_match ( '#/Type \s* /Pages#ix', $object_data ) )
		   {
			if  ( $this -> GetObjectReferences ( $object_id, $object_data, '/Kids', $references ) )
			   {
				preg_match ( '#/Count \s+ (?P<count> \d+)#ix', $object_data, $match ) ;
				$page_count		=  ( isset ( $match [ 'count' ] ) ) ?  ( integer ) $match [ 'count' ] : false ;
				$reference_count	=  count ( $references ) ;

				if  ( $page_count  !==  false  &&  $reference_count  !=  $page_count )
				   {
					warning ( "Object #$object_id : Page count given by the /Count parameter ($page_count) differs from the actual number of objects " .
						  "referenced by the /Kids parameter ($reference_count)." ) ;
				    }

				$this -> PageObjects [ $object_id ]	=  $references ;
			    }
		    }
		// Object listing the other objects that are contained in this page (/Type/Page and /Contents[x1 0 R ... xn 0 R]
		else if  ( preg_match ( '#/Type \s* /Page\b#ix', $object_data ) )
		   {
			if  ( $this -> GetObjectReferences ( $object_id, $object_data, '/Contents', $references ) )
			   {
				preg_match ( '#/Parent \s+ (?P<parent> \d+)#ix', $object_data, $match ) ;

				if  ( ! isset ( $match [ 'parent' ] ) )
				   {
					warning ( "Object #$object_id : No parent object given (/Parent)." ) ;
				    }
				else 
					$this -> PageContentObjects [ $object_id ]	=  [ 'parent' => ( integer ) $match [ 'parent' ], 'objects' => $references ] ;
			    }
		    }
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        MapObjects - Builds a correspondance between object and page numbers.
	
	    PROTOTYPE
	        $pagemap -> MapObjects ( ) ;
	
	    DESCRIPTION
	        Builds a correspondance between object and page numbers. The page number corresponding to an object id 
		will after that be available using the array notation.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  MapObjects ( )
	   {
		if  ( count ( $this -> PageObjects ) )
		    {
			foreach  ( $this -> PageContentObjects  as  $kids_id => $page_contents )
			   {
				foreach  ( $page_contents [ 'objects' ]  as  $id )
				   {
					$index	=  1 ;

				
					foreach  ( $this -> PageObjects [ $page_contents [ 'parent' ] ]  as  $parent_id )
					   {
						if  ( $parent_id  ==  $kids_id )
							$this -> PageNumbers [ $id ]	=  $index ;

						$index ++ ;
					    }
				    }
			    }
		     }
		else
		    {
			$index	=  1 ;

			foreach  ( $this -> PageContentObjects  as  $kids_id => $page_contents )
			   {
				foreach  ( $page_contents [ 'objects' ]  as  $id )
				   {
					$this -> PageNumbers [ $id ]	=  $index ;
				    }

				$index ++ ;
			    }
		     }

		return ( 0 ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    Interfaces implementation.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  count ( )
	   { return ( count ( $this -> PageNumbers ) ) ; }

	public function  offsetExists ( $object_id )
	   { return ( isset ( $this -> PageNumbers [ $object_id ] ) ) ; }

	public function  offsetGet ( $object_id ) 
	   { 
		if ( isset ( $this -> PageNumbers [ $object_id ] ) )
			return ( $this -> PageNumbers [ $object_id ] ) ;
		else 
			return ( false ) ;
	    }

	public function  offsetSet ( $offset, $value )
	   { error ( new PdfToTextException ( "Unsupported operation." ) ) ; }

	public function  offsetUnset ( $offset )
	   { error ( new PdfToTextException ( "Unsupported operation." ) ) ; }
    }


/*==============================================================================================================

    class PdfImage -
        Holds image data coming from pdf.

  ==============================================================================================================*/
class  PdfImage			extends  PdfObjectBase 
   {
	// Iage resource that can be used to process image data, using the php imagexxx() functions
	public		$ImageResource ;
	// Original image data
	protected	$ImageData ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    CONSTRUCTOR
	        Creates a PdfImage object with a resource that can be used with imagexxx() php functions.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( $image_data )
	   {
		$this -> ImageData	=  $image_data ;
		$this -> ImageResource	=  imagecreatefromstring ( $image_data ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        SaveAs - Saves the current image to a file.
	
	    PROTOTYPE
	        $pdfimage -> SaveAs ( $output_file, $image_type = IMG_JPEG ) ;
	
	    DESCRIPTION
	        Saves the current image resource to the specified output file, in the specified format.
	
	    PARAMETERS
	        $output_file (string) -
	                Output filename.

		$image_type (integer) -
			Output format. Can be any of the predefined php constants IMG_*.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public function  SaveAs ( $output_file, $image_type = IMG_JPEG )
	   {
		$image_types		=  imagetypes ( ) ;

		switch  ( $image_type )
		   {
			case	IMG_JPEG :
			case	IMG_JPG :
				if  ( ! ( $image_types & IMG_JPEG )  &&  ! ( $image_types & IMG_JPG ) )
					error ( new PdfToTextException ( "Your current PHP version does not support JPG images." ) ) ;

				imagejpeg ( $this -> ImageResource, $output_file, 100 ) ;
				break ;

			case	IMG_GIF :
				if  ( ! ( $image_types & IMG_GIF ) )
					error ( new PdfToTextException ( "Your current PHP version does not support GIF images." ) ) ;

				imagegif ( $this -> ImageResource, $output_file ) ;
				break ;

			case	IMG_PNG :
				if  ( ! ( $image_types & IMG_PNG ) )
					error ( new PdfToTextException ( "Your current PHP version does not support PNG images." ) ) ;

				imagepng ( $this -> ImageResource, $output_file, 0 ) ;
				break ;
				
			case	IMG_WBMP :
				if  ( ! ( $image_types & IMG_WBMP ) )
					error ( new PdfToTextException ( "Your current PHP version does not support WBMP images." ) ) ;

				imagewbmp ( $this -> ImageResource, $output_file ) ;
				break ;
				
			case	IMG_XPM :
				if  ( ! ( $image_types & IMG_XPM ) )
					error ( new PdfToTextException ( "Your current PHP version does not support XPM images." ) ) ;

				imagexbm ( $this -> ImageResource, $output_file ) ;
				break ;

			default :
				error ( new PdfToTextException ( "Unknown image type #$image_type." ) ) ;
		    }
	    }
    }