<?php
/**************************************************************************************************************

    NAME
	PdfToText.phpclass

    DESCRIPTION
    	A class for extracting text from Pdf files.
	Usage is very simple : just instantiate a PdfToText object, specifying an input filename, then use the
	Text property to retrieve PDF textual contents :

		$pdf	=  new PdfToText ( 'sample.pdf' ) ;
		echo $pdf -> Text ;		// or : echo ( string ) $pdf ;

	Or :

		$pdf	=  new PdfToText ( ) ;
		$pdf -> Load ( 'sample.pdf' ) ;
		echo $pdf -> Text ;


    AUTHOR
        Christian Vigh, 04/2016.

    CREDITS
	I was recently asked at work to implement a pdf text extractor. They provided me with an existing PHP
	source code which consisted in a set of functions (not a class). Alas, the name of the author was not
	present in the source code but I have noticed that two or three classes at http://www.phpclasses.org
	were reusing the set of functions he/she had implemented, because they kept the same names for the
	methods : getTextUsingTransformations, getCharTransformations, getDecodedStream and so on.
	Although the original code was not working for more complex cases, it did a rather good job. Anyway,
	apart from the invaluable understanding of the pdf file format this sample code gave to me, I only
	borrowed two functions, decodeAsciiHex and decodeAscii85, which decode pdf streams using methods I was
	not aware of. However, I could not test them since I have had no sample pdf files using these encoding
	methods.
	This work has also been inspired from that of Adeel Ahmad Khan (https://github.com/adeel/php-pdf-parser)
	which gave me further understanding of the pdf file format.
	And, of course, the PDF file format reference :
		http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf
	I didn't take time to thoroughly read this 1300 pages-long document, since I only had limited time to
	implement that and, thanks to the contributors listed above, I was able to implement it in 1.5 days
	(in PHP4). This current class is a complete reworking for PHP 5 of my initial work, which should be
	able to handle more complicated situations.

    TESTING
	I tested this class with various samples from various origins : Acrobat, PdfCreator, Word and so on.
	I even used it to extract text from the PDF reference document and from the Microsoft Rich Text format
	specification 1.9 (available here : https://www.microsoft.com/en-us/download/details.aspx?id=10725).
	All provided acceptable results.

    LIMITATIONS
	As this class generates text, don't expect the original formatting to be preserved. I have made my best
	to compensate this, but since PDF uses special drawing instructions to position the text on the page,
	it was not possible to handle all the cases. I found especially that documents generated by PdfCreator
	were more difficult to render than other converters, since it uses a combination of absolute positioning
	instructions followed by relative ones. So my advice in this case, if the results are not satisfactory,
	is to use Acrobat or Word to save again your original document in PDF format.

    PDF FILE FORMAT
	I will focus here on the small subparts of the PDF file format that are of interest in the process of
	extracting textual information from a file.

	If you edit a PDF file using an editor such as Notepad++, you will see something like that :

		%PDF-1.4
		%«Ïè¢
		5 0 obj
		<</Length 6 0 R/Filter /FlateDecode>>
		stream
			... binary data ...
		endobj
		...
		7 0 obj
		<</BaseFont/AKCXNM+Calibri/FontDescriptor 8 0 R/ToUnicode 11 0 R/Type/Font
		/FirstChar 1/LastChar 59/Subtype/TrueType>>
		endobj

	The first line indicates the PDF version that was used to generate the file. Then you will see a list
	of declarations looking like :

		x 0 obj
			...
		endobj

	These are the objects that constitute your pdf document. An object can contain textual data, such as
	object #7 in the above example, or a binary stream delimited by the stream/endstream keywords, and
	preceded by options specified in ascii text. The format of the encoded binary stream is given by the
	/Flate, /Ascii85 or /AsciiHex options.

	Apart from the options understood by the PDF renderer, you won't be able to find any plain text in
	your pdf document. This one has been put in "obj" declarations and encoded within a stream, and you will
	need to decode it first.

	There are three types of objects that are of interest to us :
	- Objects containing the document text : there are encoded within a stream, and contain PDF drawing
	  instructions.
	- Font declarations : they specify the name of the fonts we use in the document.
	- Character maps : fonts can use characters maps (which can be seen as substitution tables) by
	  providing a "/ToUnicode x" option, where "x" is the character map object id

	FONT DECLARATIONS
		So far, I have found that font declarations can take two forms :

			7 0 obj
			<</BaseFont/AKCXNM+Calibri/FontDescriptor 8 0 R/ToUnicode 11 0 R/Type/Font
			/FirstChar 1/LastChar 59/Subtype/TrueType>>
			endobj

		or :

			9 0 obj
			<</R7 20 0 R/R9 22 0 R>>
			<</BaseFont/AKCXNM+Calibri/FontDescriptor 8 0 R/ToUnicode 11 0 R/Type/Font
			/FirstChar 1/LastChar 59/Subtype/TrueType>>
			<</BaseFont/AKCXNM+Courier/FontDescriptor 8 0 R/ToUnicode 14 0 R/Type/Font
			/FirstChar 1/LastChar 59/Subtype/TrueType>>
			endobj

		Note that these declerations are delimited with doubled angle-brackets "<<" and ">>".

		The first example specifies a font whose id will be that of its enclosing object, ie #7. Text
		drawing instructions will set it as the current font by using the "/R7" operator (see
		"TEXT BLOCKS" later in this paragraph). It also uses a character map, #11, which is the id
		of the object holding this character map.

		The second example specifies two fonts, using character maps #11 and #14, respectively. Since
		their id cannot be the object number, #9, because they cannot share the same id, a additional
		declaration has been put :

			<</R7 20 0 R/R9 22 0 R>>

		This means that the first font in the declaration will be set using the "/R7" operator when
		used in text blocks, and the second with "/R9".

		Although font declarations usually appear in clear text, they also can be encoded as a stream.

	CHARACTER MAPS
		Character maps are to be seen as substitution tables for characters. They can have two forms
		(at least) ; the first one is for individual character substitution :

			n beginbfchar
			srcCode dstString
			endbfchar

		For example :

			1 beginbfchar
			<3A51><D840DC3E>
			endbfchar

		This means that any reference in a text drawing block to the unicode character \u3A51 will be
		replaced with the sequence \uD840\uDC3E.

		The second type of substitution table works on ranges of characters ; it can have two forms, as
		show in the following example :

			2 beginbfrange
			<0000><005E><0020>
			<005F><0061>[ <00660066> <00660069> <00660066006C> ]
			endbfrange

		The first mapping says : "map characters from the range \u0000..\u005E to \u0020..\u007E". The
		second one, using an array notation, says :
		. Map \u005F to \u0066+\u0066
		. Map \u0060 to \u0066+\u0069
		. Map \u0061 to \u0066+\u0066+\u006C

		I have seen no example of character maps being in clear text. They are (normally) encoded in a
		stream.

		The whole stuff is presented this way within an object :

			16 0 obj
			<< /Length 433 >>
			stream
			/CIDInit /ProcSet findresource begin
			12 dict begin
			begincmap
			/CIDSystemInfo
			<< /Registry ( Adobe )
			/Ordering ( UCS )
			/Supplement 0
			>> def
			/CMapName /Adobe?Identity?UCS def
			/CMapType 2 def
			1 begincodespacerange
			< 0000 >< FFFF >
			endcodespacerange
			2 beginbfrange
			< 0000 >< 005E >< 0020 >
			< 005F >< 0061 >[ < 00660066 > < 00660069 > < 00660066006C > ]
			endbfrange
			1 beginbfchar
			<3A51><D840DC3E>
			endbfchar
			endcmap
			CMapName currentdict /CMap defineresource pop
			end
			end
			endstream
			endobj

		The object number being the one referenced by the /ToUnicode option of a font declaration.

	TEXT DRAWING OBJECTS
		Text drawing objects contain a sequence of operators for drawing text. They are too numerous
		to be listed here, but the ones that are of interest for us are described below :

		- BT, ET :
			"BT" starts a text drawing sequence, "ET" ends it. All the following instructions
			are enclosed between "BT" and "ET" keywords.
		- /Rx :
			Set font "x" as the current font.
		- a b c d x y Tm :
			Defines the "text matrix" for the current drawing. "text matrix" is not a quickly
			understandable notion if you rapidly browsed the pdf specification as I did, but
			just keep in mind that the next text drawing instruction will be located at position
			(x,y).
			Why trying to interpret this since the PdfToText class do not handle positioning ?
			The reason is simple ; I have had a sample pdf file which contained the following :

				Mail : someone@somewhere.com

			The code from the Unknown Contributor gave this :

				Mail
				:
				someone@somewhere.com

			The colon character was shown on a separate line (using the Unknown Contributor
			code, the email also vanished from the output, but I did not find the reason why).
			This was due to the fact that the generated pdf code was :

				0 0 0 0 70 570.11 Tm
				[(Mai)3.222(l)2.147( )4.445] TJ
				0 0 0 0 111.15 570.11 Tm
				[(: )] TJ
				0 0 0 0 120.75 570.11 Tm
				[(someone)4.445(@)3.125(somewhere.com)] TJ

			(see below for an explanation on text output operators).
			This meant that, for some unknown reason, the text was output in three parts :
			"mail ", ": " and "someone@somewhere.com". However, the "Tm" operator was used before
			each text output, repositioning the y-coordinate to 570.11.
			The PdfToText class handles the catenation of texts having the same y-coordinate in the
			case where Tm instructions are used ; note however that it will not correctly handle
			text output if the x-coordinates are not sorted in ascending order

		- (sometext)' 		or :
		  [(text1)delta1(text2)delta2...(textn)] TJ or Tj :
			Outputs the specified text and positions to the next line. The text to be output is
			always enclosed with parentheses.
			The first form uses raw text output with default spacing between characters.
			The second form (array form) can specify positive or negative spacing adjustments
			between characters (delta1 to deltan).
			The specification of the text to be output can take two forms, depending on whether
			the current font has an associated character map or not.
			- Fonts without an associated character map :
				Every character will be interpreted as is, except if an escape sequence is
				used. Escape sequences are the same as in the C language : \b for backspace,
				\f for form feed, \t for tab, \r for carriage return, \n for newline.
				Escape sequences are also used for special characters ; for example, displaying
				a closing parenthesis will be specified as this :

					[(\))...] TJ
			- Fonts with an associated character map :
				Each character to be output is an indirection through the character map table.
				For example, if you have the following character map :

					2 beginbfrange
					<0001><0001><0020>
					<0002><0002><0041>
					endbfrange

				(which thanslates character \u0001 to a space, and character \u0002 to uppercase
				A), the text " A " will be specified as :

					[(SOH]delta1(STX)delta2(SOH)] TJ

				Where "SOH" and "STX" are the official Ascii names for character 1 and 2,
				respectively.

				Beware ! C-like escape sequences are not handled (except for escaping special
				characters such as ")"), but indexes 10 and 13 in the character map will always
				be represented as "\n" and "\r" respectively.

    HISTORY
    [Version : 1.0]    [Date : 2016/04/16]     [Author : CV]
        Initial version.

 **************************************************************************************************************/


/*==============================================================================================================

    PdfToText class -
	A class for extracting text from Pdf files.

 ==============================================================================================================*/
class  PdfToText 	// extends Object
   {
	public static 		$DEBUG 		=  true ;

	// Possible encoding types for streams inside objects ; "unknown" means that the object contains no stream
	const 	PDF_UNKNOWN_ENCODING 		=  0 ;
	const 	PDF_ASCIIHEX_ENCODING 		=  1 ;
	const 	PDF_ASCII85_ENCODING		=  2 ;
	const 	PDF_FLATE_ENCODING		=  3 ;

	// Current filename
	public 		$Filename 		=  false ;
	// Extracted text
	public		$Text			=  '' ;

	// Font mappings
	protected 	$FontTable		=  false ;


	/*--------------------------------------------------------------------------------------------------------------

	    CONSTRUCTOR
	        $pdf	=  new PdfToText ( $filename = null ) ;

	    DESCRIPTION
	        Builds a PdfToText object and optionally loads the specified file's contents.

	    PARAMETERS
	        $filename (string) -
	                Optional PDF filename whose text contents are to be extracted.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  	__construct ( $filename = null )
	   {
		// parent::__construct ;

		if  ( $filename )
			$this -> Load ( $filename ) ;
	    }


	public function  __tostring ( )
	   { return ( $this -> Text ) ; }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        Load - Loads text contents from a PDF file.

	    PROTOTYPE
	        $pdf -> Load ( $filename ) ;

	    DESCRIPTION
	        Extracts text contents from the specified PDF file. Once processed, text contents will be available
		through the "Text" property.

	    PARAMETERS
	        $filename (string) -
	                Optional PDF filename whose text contents are to be extracted.

	 *-------------------------------------------------------------------------------------------------------------*/
	function  Load ( $filename )
	   {
		// Check if the file exists
		if  ( ! file_exists ( $filename ) )
			throw ( new  \Exception ( "File \"$filename\" does not exist." ) ) ;

		// Load its contents
		$contents 	=  file_get_contents ( $filename, FILE_BINARY ) ;

		// Check that this is a PDF file
		if  ( ! preg_match ( '/^ %PDF- (?P<version> \d+ (\. \d+)*) /ix', $contents, $match ) )
			throw ( new \Exception ( "File \"$filename\" is not a valid PDF file." ) ) ;

		$this -> PdfVersion 	=  $match [ 'version' ] ;

		// Initializations
		$this -> Text 		=  '' ;
		$this -> FontTable 	=  new PdfTexterFontTable ( ) ;
		$this -> Filename 	=  $filename ;

		// Extract pdf objects that are enclosed by the "obj" and "endobj" keywords
		if  ( ! preg_match_all ( '/(?P<num> \d+) \s+ \d+ \s+ obj (?P<object> .*?) endobj/imsx', $contents, $object_matches ) )
			return ( false ) ;

		// Character maps encountered so far
		$cmaps			=  [] ;

		// Loop through the objects
		$text		=  [] ;

		for ( $i = 0 ; $i < count ( $object_matches [ 'object' ] ) ; $i ++ )
		   {
		   	$object_data 	=  $object_matches [ 'object' ] [$i] ;
		   	$object_number 	=  $object_matches [ 'num' ] [$i] ;

			// Some font definitions are in clear text in an object, some are encoded in a stream within the object
			// We process here the unencoded ones
			if  ( PdfTexterFontTable::IsFont ( $object_data ) )
			   {
				$this -> FontTable -> Add ( $object_number, $object_data ) ;
				continue ;
			    }
			// Check if there is an association between font number and object number
			else if  ( PdfTexterFontTable::IsFontMap ( $object_data ) )
		   	   {
				$this -> FontTable -> AddFontMap ( $object_number, $object_data ) ;
				continue ;
			    }
			// Ignore other objects that do not contain an encoded stream
		   	else if  ( ! preg_match ( '/stream \r? \n (?P<stream> .*?) endstream/imsx', $object_data, $stream_match ) )
		   		continue ;

			// Isolate stream data and try to find its encoding type
			$stream_data 		=  $stream_match [ 'stream' ] ;
			$type 			=  $this -> GetEncodingType ( $object_data ) ;

			// Ignore this stream if the object does not contain an encoding type (/FLATE, /ASCIIHEX or /ASCII85)
			if  ( $type  ==  self::PDF_UNKNOWN_ENCODING )
				continue ;

			// Decode the encoded stream
			$decoded_stream_data 	=  $this -> DecodeData ( $stream_data, $type ) ;

			// Check for character maps
			if  ( PdfTexterCharacterMap::IsCharacterMap ( $decoded_stream_data ) )
			   {
				$cmaps []	=  new PdfTexterCharacterMap ( $object_number, $decoded_stream_data ) ;
			    }
			// Font definitions
			else if  ( PdfTexterFontTable::IsFont ( $decoded_stream_data ) )
			   {
				$this -> FontTable -> Add ( $object_number, $decoded_stream_data ) ;
			    }
			// Plain text (well, in fact PDF drawing instructions)
			else if  ( $this -> IsText ( $object_data, $decoded_stream_data ) )
			   {
				$text [ $object_number ]	=  $decoded_stream_data ;
			    }
		    }

		// Associate character maps with declared fonts
		foreach  ( $cmaps  as  $cmap )
			$this -> FontTable -> AddCharacterMap ( $cmap ) ;

		// Current font defaults to -1, which means : take the first available font as the current one.
		// Sometimes it may happen that text drawing instructions do not set a font at all (PdfPro for example)
		$current_font	=  -1 ;

		// Extract text from the collected TEXT elements
		foreach  ( $text  as  $id => $str )
		   {
			$text	=  $this -> ExtractText ( $id, $str, $current_font ) ;

			// Put a form feed between each text block - not sure it is appropriate
			if  ( $this -> Text )
				$this -> Text	.=  "\f" ;

			$this -> Text	.=  $text ;
		    }

		return ( true ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        IsText - Check if the specified object contents denote a text stream.

	    PROTOTYPE
	        $status		=  $this -> IsText ( $object_data, $decoded_stream_data ) ;

	    DESCRIPTION
	        Checks if the specified object contents denote a text stream.

	    PARAMETERS
	        $object_data (string) -
	                Object data, ie the contents located between the "obj" and "endobj" keywords.

	        $decoded_stream_data (string) -
	        	The flags specified in the object data are not sufficient to be sure that we have a block of
	        	drawing instructions. We must also check for certain common instructions to be present.

	    RETURN VALUE
	        True if the specified contents MAY be text contents, false otherwise.

	    NOTES
		I do not consider this method as bullet-proof. There may arise some cases where non-text blocks can be
		mistakenly considered as text blocks, so it is subject to evolve in the future.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  IsText ( $object_data, $decoded_stream_data )
	   {
		if  ( stripos ( $object_data, '/Filter'  )  !==  false  &&
		      stripos ( $object_data, '/Length'  )  !==  false  &&
		      stripos ( $object_data, '/Length1' )  ===  false  &&
		      stripos ( $object_data, '/Type'    )  ===  false  &&
		      stripos ( $object_data, '/Subtype' )  ===  false )
		   {
		   	if  ( preg_match ( '/\\b(BT|Tf|Td|TJ|Tj|Tm)\\b/', $decoded_stream_data ) )
				return ( true ) ;
		   	else
		   		return ( false ) ;
		    }

		return ( false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        GetEncodingType - Gets an object encoding type.

	    PROTOTYPE
	        $type	=  $this -> GetEncodingType ( $object_data ) ;

	    DESCRIPTION
	        When an object is a stream, returns its encoding type.

	    PARAMETERS
	        $object_data (string) -
	                Object contents.

	    RETURN VALUE
	        Returns one of the following values :

		- PdfToText::PDF_ASCIIHEX_ENCODING :
			Hexdecimal encoding of the binary values.
			Decoding algorithm was taken from the unknown contributor and not tested so far, since I
			couldn't find a PDF file with such an encoding type.

		- PdfToText::PDF_ASCII85_ENCODING :
			Obscure encoding format.
			Decoding algorithm was taken from the unknown contributor and not tested so far, since I
			couldn't find a PDF file with such an encoding type.

		- PdfToText::PDF_FLATE_ENCODING :
			gzip/deflate encoding.

		- PdfToText::PDF_UNKNOWN_ENCODING :
			The object data does not specify any encoding at all. It can happen on objects that do not have
			a "stream" part.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  GetEncodingType ( $object_data )
	   {
		$status 	=  preg_match ( '# / (?P<encoding> (ASCIIHexDecode) | (ASCII85Decode) | (FlateDecode) ) #imsx', $object_data, $match ) ;

		if  ( ! $status )
			return ( self::PDF_UNKNOWN_ENCODING ) ;

		switch ( strtolower ( $match [ 'encoding' ] ) )
		    {
		    	case 	'asciihexdecode' 	:  return ( self::PDF_ASCIIHEX_ENCODING ) ;
		    	case 	'ascii85decode' 	:  return ( self::PDF_ASCII85_ENCODING ) ;
		    	default 			:  return ( self::PDF_FLATE_ENCODING ) ;
		     }
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        DecodeData - Decodes stream data.

	    PROTOTYPE
	        $data	=  $this -> DecodeData ( $stream_data, $type ) ;

	    DESCRIPTION
	        Decodes stream data (binary data located between the "stream" and "enstream" directives) according to the
		specified encoding type, given in the surrounding object parameters.

	    PARAMETERS
	        $stream_data (string) -
	                Contents of the binary stream.

		$type (integer) -
			One of the PDF_*_ENCODING constants, as returned by the GetEncodingType() method.

	    RETURN VALUE
	        Returns the decoded stream data.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  DecodeData ( $stream_data, $type )
	   {
		$decoded_stream_data 	=  '' ;

		switch  ( $type )
		   {
		   	case 	self::PDF_FLATE_ENCODING :
		   		$decoded_stream_data 	=  gzuncompress ( $stream_data ) ;
		   		break ;

		   	case 	self::PDF_ASCIIHEX_ENCODING :
		   		$decoded_stream_data 	=  $this -> __decode_ascii_hex ( $stream_data ) ;
		   		break ;

		   	case 	PDF_ASCII85_ENCODING :
				$decoded_stream_data 	=  $this -> __decode_ascii_85 ( $stream_data ) ;
		    }

		return ( $decoded_stream_data ) ;
	    }


	// __decode_ascii_hex -
	//	Decoder for /AsciiHexDecode streams.
	private function __decode_ascii_hex ( $input )
	    {
	    	$output 	=  "" ;
	    	$is_odd 		=  true ;
	    	$is_comment 	=  false ;

	    	for  ( $i = 0, $codeHigh =  -1 ; $i  <  strlen ( $input )  &&  $input [ $i ]  !=  '>' ; $i++ )
	    	   {
	    		$c 	=  $input [ $i ] ;

	    		if  ( $is_comment )
	    		   {
	    			if   ( $c  ==  '\r'  ||  $c  ==  '\n' )
	    				$is_comment 	=  false ;

	    			continue;
	    		    }

	    		switch  ( $c )
	    		   {
	    			case  '\0' :
	    			case  '\t' :
	    			case  '\r' :
	    			case  '\f' :
	    			case  '\n' :
	    			case  ' '  :
	    				break ;

	    			case '%' :
	    				$is_comment 	=  true ;
	    				break ;

	    			default :
	    				$code 	=  hexdec ( $c ) ;

	    				if  ( $code  ===  0  &&  $c  !=  '0' )
	    					return ( '' ) ;

	    				if  ( $is_odd )
	    					$codeHigh 	 =  $code ;
					else
	    					$output 	.=  chr ( ( $codeHigh << 4 ) | $code ) ;

	    				$is_odd 	=  ! $is_odd ;
	    				break ;
	    		    }
	    	    }

	    	if  ( $input [ $i ]  !=  '>' )
	    		return ( '' ) ;

	    	if  ( $is_odd )
	    		$output 	.=  chr ( $codeHigh << 4 ) ;

	    	return ( $output ) ;
	    }


	// __decode_ascii_85 -
	//	Decoder for /Ascii85Decode streams.
	private function  __decode_ascii_85 ( $input )
	    {
	    	$output 	=  "" ;
	    	$is_comment 	=  false ;
	    	$ords 		=  [] ;

	    	for  ( $i = 0, $state = 0  ; $i  <  strlen ( $input )  &&  $input [ $i ]  !=  '~'  ; $i ++ )
	    	   {
	    		$c 	=  $input [ $i ] ;

	    		if ( $is_comment )
	    		   {
	    			if  ( $c  ==  '\r'  ||  $c  ==  '\n' )
	    				$is_comment 	=  false ;

	    			continue ;
	    		    }

	    		if  ( $c  ==  '\0'  ||  $c  ==  '\t'  ||  $c  ==  '\r'  ||  $c  ==  '\f'  ||  $c  ==  '\n'  ||  $c  ==  ' ' )
	    			continue ;

    			if  ( $c  ==  '%' )
    			   {
    				$is_comment 	=  true ;
    				continue ;
    			    }

    			if  ( $c  ==  'z'  &&  $state  ===  0 )
    			   {
    				$output 	.= str_repeat ( chr ( 0 ), 4 ) ;
    				continue ;
    			    }

    			if  ( $c  <  '!'  ||  $c  >  'u' )
    				return ( '' ) ;

    			$code = ord ( $input [ $i ] ) & 0xff ;
    			$ords [ $state++  ] = $code - ord ( '!' ) ;

    			if  ( $state  ==  5 )
    			   {
    				$state 	=  0 ;

    				for  ( $sum = 0, $j = 0  ; $j < 5  ; $j++ )
    					$sum 	=  $sum * 85 + $ords [ $j ] ;

    				for ( $j = 3  ; $j >= 0  ; $j-- )
    					$output 	.=  chr ( $sum >> ( $j * 8 ) ) ;
    			    }
	    	    }

	    	if  ( $state === 1 )
	    		return ( '' ) ;
    		elseif  ( $state > 1 )
    		   {
    			for  ( $i = 0, $sum = 0  ; $i  <  $state  ; $i++ )
    				$sum 	+= ( $ords [ $i ] + ( $i == $state - 1 ) ) * pow ( 85, 4 - $i ) ;

    			for  ( $i = 0  ; $i  <  $state - 1  ; $i++ )
    				$output 	.=  chr ( $sum >> ( ( 3 - $i ) * 8 ) ) ;
    		    }

    		return ( $output ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
		ExtractText - extracts text from a pdf stream.

	    PROTOTYPE
		$text 	=  $this -> __extract_text ( $object_id, $data, &$current_font ) ;

	    DESCRIPTION
	        Extracts text from decoded stream contents.

	    PARAMETERS
	    	$object_id (integer) -
	    		Object id of this text block.

	    	$data (string) -
	    		Stream contents.

		$current_font (integer) -
			Id of the current font, which should be found in the $this->FontTable property, if anything
			went ok.
			This parameter is required, since text blocks may not specify a new font resource id and reuse
			the one that waas set before.

	    RETURN VALUE
		Returns the decoded text.

	    NOTES
		The PDF language can be seen as a stack-driven language  ; for example, the instruction defining a text
		matrix ( "Tm" ) expects 6 floating-point values from the stack :

			0 0 0 0 x y Tm

		It can also specify specific operators, such as /Rx, which sets font number "x" to be the current font,
		or even "<< >>" constructs that we can ignore during our process of extracting textual data.
		Actually, we only want to handle a very small subset of the Adobe drawing language ; These are :
		- "Tm" instructions, that specify, among others, the x and y coordinates of the next text to be output
		- "/R" instructions, that specify which font is to be used for the next text output. This is useful
		  only if the font has an associated character map.
		- "/F", same as "/R", but use a font map id instead of a direct object id.
		- Text, specified either using a single notation ( "(sometext)" ) or the array notation
		  ( "[(...)d1(...)d2...(...)]" ), which allows for specifying inter-character spacing.
		 - "Tf" instructions, that specifies the font size. This is to be able to compute approximately the
		   number of empty lines between two successive Y coordinates in "Tm" instructions
		 - "TL" instructions, that define the text leading to be used by "T*"

		This is why I choosed to decompose the process of text extraction into three steps :
		- The first one, the lowest-level step, is a tokenizer that extracts individual elements, such as "Tm",
		  "TJ", "/Rx" or "510.77". This is handled by the __next_token() method.
		- The second one, __next_instruction(), collects tokens. It pushes every floating-point value onto the
		  stack, until an instruction is met.
		- The third one, ExtractText(), processes data returned by __next_instruction(), and actually performs
		  the (restricted) parsing of text drawing instructions.

	 *-------------------------------------------------------------------------------------------------------------*/
	private function  ExtractText ( $object_id, $data, &$current_font )
	   {
		if  ( PdfToText::$DEBUG )
		   {
			echo "----------------------------------- TEXT #$object_id\n" ;
			echo $data ;
		    }

		// Index into the specified block of text-drawing instructions
		$data_index 		=  0 ;

		$data_length 		=  strlen ( $data ) ;		// Data length
		$result 		=  '' ;				// Resulting string

		// Y-coordinate of the last seen "Tm" instruction
		$last_goto_y 		=  -1 ;

		// When true, the current text should be output on the same line as the preceding one
		$use_same_line 		=  false ;

		// Instruction preceding the current one
		$last_instruction 	=  true ;

		// Current font size
		$current_font_size 		=  0 ;

		// Extra newlines to add before the current text
		$extra_newlines 		=  0 ;

		// Text leading used by T*
		$text_leading 			=  0 ;

		// Loop through instructions
		while  ( ( $instruction =  $this -> __next_instruction ( $data, $data_length, $data_index ) )  !==  false )
		   {
			// Character position after the current instruction
			$data_index 	=  $instruction [ 'next' ] ;

			// Process current instruction
			switch  ( $instruction [ 'instruction' ] )
			   {
				// "Tm" : Output text on the same line, if the "y" coordinates are equal
			   	case 	'goto' :
			   		if  ( $instruction [ 'y' ]  ==  $last_goto_y )
			   		   {
			   			$use_same_line 		=  true ;
			   			$extra_newlines 	=  0 ;
			   		    }
					else
					   {
					   	// Compute the number of newlines we have to insert between the current and the next lines
					   	if  ( $current_font_size )
					   		$extra_newlines =  ( integer ) ( ( $last_goto_y - $instruction [ 'y' ] - $current_font_size ) / $current_font_size ) ;

						$use_same_line 		=  ( $last_goto_y  ==  -1 ) ;
					   	$last_goto_y 		=  $instruction [ 'y' ] ;
					    }

			   		break ;

				// "/Rx" : sets the current font
			   	case 	'resource' :
			   		$current_font 		=  $instruction [ 'resource' ] ;
			   		break ;

			   	case 	'fontsize' :
			   		$current_font_size 	=  $instruction [ 'size' ] ;
			   		break ;

			   	// 'TL' : text leading to be used for the next "T*" in the flow
			   	case 'leading' :
			   		$text_leading 		=  $instruction [ 'size' ] ;
			   		break ;

				// An "nl" instruction means TJ, Tj, T* or "'"
			   	case 	'nl' :
			   		if  ( ! $instruction [ 'conditional' ] )
			   		   {
			   		   	if  ( $instruction [ 'leading' ]  &&  $text_leading  &&  $current_font_size )
			   		   	   {
			   		   		$count 	=  ( integer ) ( ( $text_leading - $current_font_size ) / $current_font_size ) ;
			   		   		$extra	=  str_repeat ( PHP_EOL, $count ) ;
			   		   	    }
			   		   	else
			   		   		$extra 	=  PHP_EOL ;

			   			$result 	.=  $extra ;
			   		    }

			   		break ;

				// Raw text (enclosed by parentheses) or array text (enclosed within square brackets)
				// is returned as a single instruction
			   	case 	'text' :
					// Check if we have to insert a newline
			   		if ( isset ( $last_instruction [ 'instruction' ] )  &&  $last_instruction [ 'instruction' ]  !=  'text'  &&  ! $use_same_line )
			   			$result 	.=  PHP_EOL ;

			   		// Roughly simulate spacing between lines by inserting newline characters
			   		if  ( $extra_newlines  > 0 )
			   		   {
			   			$result 	.=  str_repeat ( PHP_EOL, $extra_newlines ) ;
			   			$extra_newlines  =  0 ;
			   		    }

					// Fonts having character maps will require some special processing
					if  ( $this -> FontTable -> IsMapped ( $current_font ) )
					   {
						// Lop through each text value
			   			foreach  ( $instruction [ 'values' ]  as  $text )
			   			   {
			   		   		$is_hex 	=  ( $text [0]  ==  '<' ) ;
			   			   	$length 	=  strlen ( $text ) - 2 ;
			   			   	$text 		=  substr ( $text, 1, $length ) ;

			   			   	// Characters are encoded within angle brackets ( "<>" ). There is a single value in it
			   			   	if  ( $is_hex )
			   			   	   {
			   			   		$ch 	=  ( hex2bin ( $text ) ) ;

			   			   		$result .= $this -> FontTable -> MapCharacter ( $current_font, $ch ) ;
			   			   	    }
							// Character strings within parentheses.
							// For every text value, use the character map table for substitutions
							else
							   {
				   		   		for  ( $i = 0 ; $i  <  $length ; $i ++ )
				   		   		   {
				   		   			$ch 	=  $text [$i] ;

									// ... but don't forget to handle escape sequences "\n" and "\r" for characters
									// 10 and 13
				   		   			if  ( $ch  ==  '\\' )
				   		   			   {
				   		   				$ch 	=  $text [++$i] ;

				   		   				switch  ( $ch )
				   		   				   {
				   		   					case 	'n' 	:  $ch =  "\n" ; break ;
				   		   					case 	'r' 	:  $ch =  "\r" ; break ;
				   		   				    }
				   		   			    }

									// Add substituted character to the output result
									$result		.=  $this -> FontTable -> MapCharacter ( $current_font, $ch ) ;
				   		   		    }
							    }
			   		   	    }
			   		    }
					// For fonts having no associated character map, we simply encode the string in UTF8
					// after the C-like escape sequences have been processed
			   		else
			   		   {
			   			foreach  ( $instruction [ 'values' ]  as  $text )
			   				$result 	.=  utf8_encode ( $this -> Unescape ( substr ( $text, 1, strlen ( $text ) - 2 ) ) ) ;
			   		    }
			    }

			// Remember last instruction - this will help us into determining whether we should put the next text
			// on the current or following line
			$last_instruction 	=  $instruction ;
		    }

		$result 	.=  PHP_EOL . "\f" ;

		// I noticed, with the RTF specification file sample, that the hyphen in hyphenated words can be placed on a
		// separate line ; try to correct this, although it does not seem pertinent
		$result 	=  str_replace ( [ "\r\n-\r\n", "\n-\n", "-\r\n", "-\n" ], '', $result ) ;

		return ( $result ) ;
	    }


	// __next_instruction -
	//	Retrieves the next instruction frm the drawing text block.
	function  __next_instruction ( $data, $data_length, $index )
	   {
		static 	$last_instruction 	=  false ;

		// Constructs such as
		if  ( $last_instruction )
		   {
			$result 		=  $last_instruction ;
			$last_instruction	=  false ;

			return ( $result ) ;
		    }

		// Holds the floating-point values encountered so far
		$number_stack 	=  [] ;

		// Loop through the stream of tokens
		while  ( ( $part = $this -> __next_token ( $data, $data_length, $index ) )  !==  false )
		   {
			$token 		=  $part [0] ;
			$next_index 	=  $part [1] ;

			// Floating-point number : push it onto the stack
			if  ( ctype_digit ( $token [0] )  ||  $token [0]  ==  '-'  ||  $token [0]  ==  '+' )
				$number_stack []	=  $token ;
			// 'Tm' instruction : return a "goto" instruction with the x and y coordinates
			else if  ( $token  ==  'Tm' )
			   {
				$x 	=  $number_stack [4] ;
				$y 	=  $number_stack [5] ;

				return ( [ 'instruction' => 'goto', 'next' => $next_index, 'x' => $x, 'y' => $y ] ) ;
			    }
			// Output text "'" instruction, with conditional newline
			else if  ( $token [0]  ==  "'" )
				return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => true, 'leading' => false ] ) ;
			// Same as above
			else if  ( $token  ==  'TJ'  ||  $token  ==  'Tj' )
				return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => true, 'leading' => false ] ) ;
			// Set font size
			else if  ( $token  ==  'Tf' )
				return ( [ 'instruction' => 'fontsize', 'next' => $next_index, 'size' => $number_stack [0] ] ) ;
			// Text leading (spacing used by T*)
			else if  ( $token  ==  'TL' )
				return ( [ 'instruction' => 'leading', 'next' => $next_index, 'size' => $number_stack [0] ] ) ;
				// Position to next line
			else if  ( $token  ==  'T*' )
				return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => false, 'leading' => true ] ) ;
			// Raw text output
			else if  ( $token [0]  ==  '(' )
			   {
			   	$next_part 	=  $this -> __next_token ( $data, $data_length, $next_index ) ;
			   	$instruction	=  [ 'instruction' => 'text', 'next' => $next_index, 'values' => [ $token ] ] ;

			   	if  ( $next_part [0]  ==  "'" )
			   	   {
			   	   	$last_instruction  	=  $instruction ;
			   	   	return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => false, 'leading' => true ] ) ;
			   	   }
			   	else
					return ( $instruction ) ;
			    }
		   	else if  ( $token [0]  ==  '<' )
			   {
			   	$next_part 	=  $this -> __next_token ( $data, $data_length, $next_index ) ;
			   	$instruction	=  [ 'instruction' => 'text', 'next' => $next_index, 'values' => [ $token ] ] ;

			   	if  ( $next_part [0]  ==  "'" )
			   	   {
			   	   	$last_instruction  	=  $instruction ;
			   	   	return ( [ 'instruction' => 'nl', 'next' => $next_index, 'conditional' => false, 'leading' => true ] ) ;
			   	   }
			   	else
					return ( $instruction ) ;
			    }
			    // Text specified as an array of individual raw text elements, and individual interspaces between characters
			else if  ( $token [0]  ==  '[' )
			   {
				$values 	=  $this -> __extract_chars_from_array ( $token ) ;
				$instruction 	=  [ 'instruction' => 'text', 'next' => $next_index, 'values' => $values ] ;

				return ( $instruction ) ;
			    }
			// "/R" : Specifies the font to be used for the next text output(s)
			else if  ( ! strncasecmp ( $token, '/R', 2 ) )
			   {
				$resource 	=  ( integer ) substr ( $token, 2 ) ;

				return ( [ 'instruction' => 'resource', 'next' => $next_index, 'resource' => $resource ] ) ;
			    }
		   	// "/F" : Specifies the font to be used for the next text output(s), using an indirect id
			else if  ( ! strncasecmp ( $token, '/F', 2 ) )
			   {
				$resource 	=  ( integer ) substr ( $token, 2 ) ;
				$id 		=  $this -> FontTable -> GetFontByMapId ( $resource ) ;

				return ( [ 'instruction' => 'resource', 'next' => $next_index, 'resource' => $id ] ) ;
			    }
			    // Other instructions : we're not that much interested in them, so clear the number stack and consider
			// that the current parameters, floating-point values, have been processed
			else
				$number_stack 	=  [] ;

			$index 		=  $next_index ;
		    }

		// End of input
		return ( false ) ;
	    }


	// __next_token :
	//	Retrieves the next token from the drawing instructions stream.
	function  __next_token ( $data, $data_length, $index )
	   {
		// Skip spaces
		while  ( $index  <  $data_length  &&  ctype_space ( $data [ $index ] ) )
			$index ++ ;

		// End of input
		if  ( $index  >=  $data_length )
			return ( false ) ;

		// The current character will tell us what to do
		$ch 	=  $data [ $index ] ;

		switch ( $ch )
		   {
			// Opening square bracket : we have to find the closing one, taking care of escape sequences
			// that can also specify a square bracket, such as "\]"
		   	case 	"[" :
		   		$pos 		=  $index + 1 ;
		   		$parent 	=  0 ;
		   		$result		=  $ch ;

		   		while  ( $pos  <  $data_length )
		   		   {
		   			$nch 	=  $data [ $pos ++ ] ;

		   			switch  ( $nch )
		   			   {
		   			   	case 	'(' :
		   			   		$parent ++ ;
		   			   		$result 	.=  $nch ;
		   			   		break ;

		   			   	case 	')' :
		   			   		$parent -- ;
		   			   		$result 	.=  $nch ;
		   			   		break ;

		   			   	case 	'\\' :
		   					$result 	.=  $nch . $data [ $pos ++ ] ;
		   					break ;

		   			   	case 	']' :
		   					$result 	.=  ']' ;

		   					if  ( ! $parent )
		   						break  2 ;
		   					else
		   						break ;

		   			   	default :
		   			   		$result 	.=  $nch ;
		   			    }
		   		    }

		   		return ( [ $result, $pos ] ) ;

			// Parenthesis : Again, we have to find the closing parenthesis, taking care of escape sequences
			// such as "\)"
		   	case 	"(" :
		   		$pos 		=  $index + 1 ;
		   		$result		=  $ch ;

		   		while  ( $pos  <  $data_length )
		   		   {
		   			$nch 	=  $data [ $pos ++ ] ;

		   			if  ( $nch  ==  '\\' )
		   				$result 	.=  $nch . $data [ $pos ++ ] ;
		   			else if  ( $nch  ==  ')' )
		   			   {
		   				$result 	.=  ')' ;
		   				break ;
		   			    }
		   			else
		   				$result 	.=  $nch ;
		   		   }

		   		return ( [ $result, $pos ] ) ;

			// A construction of the form : "<< something >>", or a unicode character
		   	case 	'<' :
		   		if (  isset ( $data [ $index + 1 ] )  &&  $data [ $index + 1 ]  ==  '<' )
		   		   {
		   		   	echo "in <<" ; exit ;
		   			$pos 	=  strpos ( $data, '>>', $index + 1 ) ;

		   			if  ( $pos  ===  false )
		   				return ( false ) ;

		   			$token 	=  substr ( $data, $index, $pos - $index + 2 ) ;

		   			return ( [ $token, $pos + 2 ] ) ;
		   		    }
		   		else if  ( isset ( $data [ $index + 1 ] )  &&  ! ctype_xdigit ( $data [ $index + 1 ] ) )
		   		   {
		   		   	echo "here";exit;
		   			$pos 	=  strpos ( $data, '>', $index + 1 ) ;

		   			if  ( $pos  ===  false )
		   				return ( false ) ;

		   			$token 	=  substr ( $data, $index, $pos - $index + 2 ) ;

		   			return ( [ $token, $pos + 2 ] ) ;
		   		   }
		   		else
		   		   {
		   		   	echo "there";exit;
		   		   	$token 	=  '<' ;
		   		   	$pos 	=  $index + 1 ;

		   		   	while  ( $pos  <  $data_length  &&  ( ctype_xdigit ( $data [ $pos ] )  ||  $data [ $pos ]  ==  '>' ) )
		   		   		$token 	.=  $data [ $pos ++ ] ;

		   		   	if  ( $pos  <  $data_length  &&  $token [ $pos ]  ==  '>' )
		   		   		return ( [ $token . '>', $pos + 1 ] ) ;
		   		   	else
		   		   		return ( false ) ;
		   		    }

			// Tick character : consider it as a keyword, in the same way as the "TJ" or "Tj" keywords
		   	case 	"'" :
		   		return ( [ "'", $index + 1 ] ) ;

			// Other cases : this may be either a floating-point number or a keyword
		   	default :
		   		$index ++ ;
		   		$value 	=  $ch ;

		   		if ( ctype_digit ( $ch )  ||  $ch  ==  '-'  ||  $ch  ==  '+' )
		   		   {
		   			while  ( $index  <  $data_length  &&
		   					( ctype_digit ( $data [ $index ] )  ||  $data [ $index ]  ==  '.' ) )
		   				$value 	.=  $data [ $index ++ ] ;
		   		    }
		   		else if  ( ctype_alpha ( $ch )  ||  $ch  ==  '/' )
		   		   {
					while  ( $index  <  $data_length  &&  ( ctype_alnum ( $data [ $index ] )  ||  $data [ $index ]  ==  '*' ) )
						$value 	.=  $data [ $index ++ ] ;
		   		    }

		   		return ( [ $value, $index ] ) ;
		    }
	    }


	// __extract_chars_from_array -
	//	Extracts characters enclosed either within parentheses (character codes) or angle brackets (hex value)
	//	from an array.
	//	Example :
	//
	//		[<0D>-40<02>-36<03>-39<0E>-36<0F>-36<0B>-37<10>-37<10>-35(abc)]
	//
	// 	will return an array having the following entries :
	//
	//		<0D>, <02>, <03>, <0E>, <0F>, <0B>, <10>, <10>, (abc)
	private function  __extract_chars_from_array ( $array )
	   {
		$length 	=  strlen ( $array ) - 1 ;
		$result 	=  [] ;

		for  ( $i = 0 ; $i  <  $length ; $i ++ )
		   {
		   	$ch 	=  $array [$i] ;

			if  ( $ch  ==  '(' )
				$endch 	=  ')' ;
			else if  ( $ch  ==  '<' )
				$endch 	=  '>' ;
			else
				continue ;

			$char 	=  $ch ;
			$i ++ ;

			while  ( $i  <  $length )
			   {
			   	if  ( $array [$i]  ==  '\\' )
			   		$char 	.=  '\\' . $array [++$i] ;
				else
					$char 	.=  $array [$i] ;

				if  ( $array [$i]  ==  $endch )
					break ;

				$i ++ ;
			   }

			$result [] 	=  $char ;
		    }

		return ( $result ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	    NAME
	        Unescape - Processes escape sequences from the specified string.

	    PROTOTYPE
	        $value	=  $this -> Unescape ( $text ) ;

	    DESCRIPTION
	        Processes escape sequences within the specified text. The recognized escape sequences are like the
		C-language ones : \b (backspace), \f (form feed), \r (carriage return), \n (newline), \t (tab).
		All other characters prefixed by "\" are returned as is.

	    PARAMETERS
	        $text (string) -
	                Text to be unescaped.

	    RETURN VALUE
	        Returns the unescaped value of $text.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function   Unescape ( $text )
	   {
		$length 	=  strlen ( $text ) ;
		$result 	=  '' ;

		for  ( $i = 0 ; $i  <  $length ; $i ++ )
		   {
		   	$ch 	=  $text [$i] ;

			if  ( $ch  ==  '\\'  &&  isset ( $text [$i+1] ) )
			   {
				$nch 	=  $text [++$i] ;

				switch  ( $nch )
				   {
				   	case 	'b' 	:  $result .=  "\b" ; break ;
				   	case 	't' 	:  $result .=  "\t" ; break ;
				   	case 	'f' 	:  $result .=  "\f" ; break ;
				   	case 	'r' 	:  $result .=  "\r" ; break ;
				   	case 	'n' 	:  $result .=  "\n" ; break ;
				   	default 	:  $result .=  $nch ;
				    }
			    }
			else
				$result 	.=  $ch ;
		    }

		return ( $result ) ;
	    }
    }


/*==============================================================================================================

    PdfTexterFontTable class -
        The PdfTexterFontTable class is not supposed to be used outside the context of the PdfToText class.
	Its purposes are to hold a list of font definitions taken from a pdf document, along with their
	associated character mapping tables, if any.
	This is why no provision has been made to design this class a a general purpose class ; its utility
	exists only in the scope of the PdfToText class.

  ==============================================================================================================*/
class 	PdfTexterFontTable 	// extends Object
   {
	// Font table
	private		$Fonts		=  [] ;
	// Font mapping between a font number and an object number
	private 	$FontMap 	=  [] ;

	// Constructor -
	//	Well, does not do anything special
	public function  __construct ( )
	   {
		// parent::__construct ( ) ;
	    }


	// Add -
	//	Adds the current font declaration to the font table. Handles special cases where font id is not
	//	given by the object id, but rather by <</Rx...>> constructs
	public function  Add ( $object_id, $font_definition )
	   {
		if  ( PdfToText::$DEBUG )
		   {
	   		echo "----------------------------------- FONT #$object_id\n" ;
			echo $font_definition ;
		    }

	   	if  ( preg_match ( '#<< \s* (?P<rscdefs> /R\d+ .*) >>#ix', $font_definition, $match ) )
		   {
			$resource_definitions	=  $match [ 'rscdefs' ] ;

			preg_match_all ( '#/R (?P<font_id> \d+) #ix', $resource_definitions, $id_matches ) ;
			preg_match_all ( '#/ToUnicode \s* (?P<cmap_id> \d+)#ix', $resource_definitions, $cmap_matches ) ;

			$count		=  count ( $id_matches [ 'font_id' ] ) ;

			for  ( $i = 0 ;  $i  <  $count ; $i ++ )
			   {
				$font_id	=  $id_matches   [ 'font_id' ] [$i] ;
				$cmap_id	=  $cmap_matches [ 'cmap_id' ] [$i] ;

				$this -> Fonts [ $font_id ]	=  new  PdfTexterFont ( $font_id, $cmap_id ) ;
			    }
		    }
		else
		   {
			if  ( preg_match ( '#/ToUnicode \s* (?P<cmap> \d+)#ix', $font_definition, $match ) )
				$cmap_id	=  $match [ 'cmap' ] ;
			else
				$cmap_id	=  0 ;

			$this -> Fonts [ $object_id ]	=  new  PdfTexterFont ( $object_id, $cmap_id ) ;
		    }
	    }


	// AddFontMap -
	//	Process things like :
	//		<</F1 26 0 R/F2 22 0 R/F3 18 0 R>>
	//	which maps font 1 (when specified with the /Fx instruction) to object 26,
	//	2 to object 22 and 3 to object 18, respectively, in the above example.
	public function  AddFontMap ( $object_id, $object_data )
	   {
		if  ( preg_match_all ( '#/F(?P<font> \d+) \s+ (?P<object> \d+)#x', $object_data, $matches ) )
		   {
		   	for ( $i = 0, $count = count ( $matches [ 'font' ] ) ; $i  <  $count ; $i ++ )
		   		$this -> FontMap [ $matches [ 'font' ] [$i] ] 	=  $matches [ 'object' ] [$i] ;
		    }
	    }


	// AddCharacterMap -
	//	Associates a character map to a font declaration that referenced it.
	public function  AddCharacterMap ( $cmap )
	   {
		foreach  ( $this -> Fonts  as  $font )
		   {
			if  ( $font -> CharacterMapId  ==  $cmap -> ObjectId )
			   {
				$font -> CharacterMap	=  $cmap ;

				return ( true ) ;
			    }
		    }

		return ( false ) ;
	    }


	// GetFontByMapId -
	//	Returns the font id (object id) associated to the specified mapped id.
	public function  GetFontByMapId ( $id )
	   {
		if  ( isset ( $this -> FontMap [ $id ] ) )
			return ( $this -> FontMap [ $id ] ) ;
		else
			return ( -1 ) ;
	    }

	// IsFont -
	//	Checks if the current object contents specify a font declaration.
	public static function  IsFont ( $object_data )
	   {
		return ( stripos ( $object_data, '/BaseFont' )  !==  false ) ;
	    }


	// IsFontMap -
	//	Checks if the code contains things like :
	//		<</F1 26 0 R/F2 22 0 R/F3 18 0 R>>
	//	which maps font 1 (when specified with the /Fx instruction) to object 26,
	//	2 to object 22 and 3 to object 18, respectively, in the above example.
	public static function  IsFontMap ( $object_data )
	   {
		if  ( preg_match ( '#<</F\d+\s+.*>>#', $object_data ) )
			return ( true ) ;
		else
			return ( false ) ;
	    }


	// IsMapped -
	//	Checks if the specified font has an associated character map.
	public function  IsMapped ( $font )
	   {
		// For text contents that did not specify a font using the /Rx instruction,
		// use the first declared font as the default font
		if  ( $font  ==  -1 )
		   {
			reset ( $this -> Fonts ) ;
			$font 	=  key ( $this -> Fonts ) ;
		    }

		return ( isset ( $this -> Fonts [ $font ] )  &&
				$this -> Fonts [ $font ] -> CharacterMap ) ;
	    }


	// MapCharacter -
	//	Returns the character associated to the specified one.
	public function  MapCharacter ( $font, $ch )
	   {
		// For text contents that did not specify a font using the /Rx instruction,
		// use the first declared font as the default font
		if  ( $font  ==  -1 )
		   {
			reset ( $this -> Fonts ) ;
			$font 	=  key ( $this -> Fonts ) ;
		    }

		if  ( isset  ( $this -> Fonts [ $font ] ) )
			return ( $this -> Fonts [ $font ] -> MapCharacter ( $ch ) ) ;
		else
			return ( utf8_encode ( $ch ) ) ;
	    }
    }



/*==============================================================================================================

    PdfTexterFont class -
        The PdfTexterFont class is not supposed to be used outside the context of the PdfToText class.
	It holds an optional character mapping table associted with this font.
	No provision has been made to design this class a a general purpose class ; its utility exists only in
	the scope of the PdfToText class.

  ==============================================================================================================*/
class  PdfTexterFont		// extends Object
   {
	// Font resource id (may be an object id, overridden by <</Rx...>> constructs
	public		$Id ;
	// Character map id, specified by the /ToUnicode flag
	public		$CharacterMapId ;
	// Optional character map, that may be set by the PdfToText::Load method just before processing text drawinf blocks
	public		$CharacterMap		=  null ;


	// Constructor -
	//	Builds a PdfTexterFont object, using its resource id and optional character map id.
	public function  __construct ( $resource_id, $cmap_id )
	   {
		// parent::__construct ( ) ;
		$this -> Id		=  $resource_id ;
		$this -> CharacterMapId	=  $cmap_id ;
	    }


	// MapCharacter -
	//	Returns the substitution string value for the specified character, if the current font has an
	//	associated character map, or the original character encoded in utf8, if not.
	public function  MapCharacter ( $ch )
	   {
		if  ( $this -> CharacterMap )
			return ( $this -> CharacterMap [ ord ( $ch ) ] ) ;
		else
			return ( utf8_encode ( $ch ) ) ;
	    }
    }


/*==============================================================================================================

    PdfTexterCharacterMap -
        The PdfTexterFont class is not supposed to be used outside the context of the PdfToText class.
	Describes a character map.
	No provision has been made to design this class a a general purpose class ; its utility exists only in
	the scope of the PdfToText class.

  ==============================================================================================================*/
class	PdfTexterCharacterMap	// extends Object
				implements  \ArrayAccess, \Countable
   {
	// Object id of the character map
	public		$ObjectId ;
	// Id of the character map (specified by the /Rx flag)
	public		$Id	;
	// Character substitution table
	protected	$Map			=  [] ;


	// Constructor -
	//	Analyzes the text contents of a CMAP and extracts mappings from the beginbfchar/endbfchar and
	//	beginbfrange/endbfrange constructs.
	public function  __construct ( $object_id, $definitions )
	   {
		if  ( PdfToText::$DEBUG )
		   {
	   		echo "----------------------------------- CMAP #$object_id\n" ;
			echo $definitions;
		    }

		preg_match ( '# /CMapName \s* /R (?P<num> \d+) #ix', $definitions, $match ) ;
		$this -> ObjectId	=  $object_id ;
		$this -> Id 		=  isset ( $match [ 'num' ] ) ?  $match [ 'num' ] : -1 ;

		// Process beginbfchar/endbfchar constructs
		if  ( preg_match_all ( '/ beginbfchar \s* (?P<chars> .*?) endbfchar /imsx', $definitions, $char_matches ) )
		    {
		    	foreach  ( $char_matches [ 'chars' ]  as  $char_list )
		    	   {
		    		$chars 		=  explode ( "\n", trim ( $char_list ) ) ;

		    		foreach ( $chars  as  $char )
		    		   {
			    		if  ( preg_match ( '/ < \s* (?P<src> [0-9a-f]+) \s*> \s* < \s* (?P<dst> [0-9a-f]+) \s* > /imx', $char, $char_match ) )
			    		   {
						$src 	=  hexdec ( $char_match [ 'src' ] ) ;
						$dst 	=  hexdec ( $char_match [ 'dst' ] ) ;

						$this -> Map [ $src ] 	=  $dst ;
			    		    }
		    		    }
		    	    }
		     }

		// Process beginbfrange/endbfrange constructs
		if  ( preg_match_all ( '/ beginbfrange \s* (?P<ranges> .*?) endbfrange /imsx', $definitions, $range_matches ) )
		   {
			foreach  ( $range_matches [ 'ranges' ]  as  $range_list )
			   {
				$ranges 	=  explode ( "\n", trim ( $range_list ) ) ;

				// Loop through each range definition
				foreach  ( $ranges  as  $range )
				   {
					// Normal form :
					//	<from><to><start>
					//	Generates mappings from start+from to start+to.
					if  ( preg_match ( '/ <\s* (?P<from> [0-9a-f]+) \s*> \s* <\s* (?P<to> [0-9a-f]+) \s* > \s* <\s* (?P<subst> [0-9a-f]+) \s* > /imx',
									$range, $range_match ) )
					   {
						$from 		=  hexdec ( $range_match [ 'from'  ] ) ;
						$to 		=  hexdec ( $range_match [ 'to'    ] ) ;
						$subst 		=  hexdec ( $range_match [ 'subst' ] ) ;

						for  ( $i = $from, $count = 0 ; $i  <=  $to ; $i ++, $count ++ )
							$this -> Map [$i] 	=  $subst + $count ;
					    }
					// Array form :
					//	<from><to>[ value1, value2, ... valuen ]
					//	Generates mapping from "from" to "to" using the specified values. The value count
					//	between square brackets must be the same as to - from + 1.
				   	else if  ( preg_match ( '/ < \s* (?P<from> [0-9a-f]+) \s* > \s* < \s* (?P<to> [0-9a-f]+) \s* > \s* \[(?P<subst> .*?)\] /imx',
									$range, $range_match ) )
					   {
						$from 		=  hexdec ( $range_match [ 'from'  ] ) ;
						$to 		=  hexdec ( $range_match [ 'to'    ] ) ;
						$subst 		=  preg_split ( '/\s+/',  trim ( $range_match [ 'subst' ] ) ) ;

						for  ( $i = $from, $count = 0 ; $i  <=  $to ; $i ++, $count ++ )
							$this -> Map [$i] 	=  hexdec ( $subst [ $count ] ) ;
					    }
				   }
			    }
		    }

	    }


	// IsCharacterMap -
	//	Checks if the specified text contents represent a character map definition or not.
	public static function  IsCharacterMap  ( $decoded_data )
	   {
		return ( stripos ( $decoded_data, 'begincmap' )  !==  false ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------

	        Interface implementations.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  count ( )
	   { return ( count ( $this -> Map ) ) ; }


	public function  offsetExists ( $offset )
	   { return  ( isset ( $this -> Map [ $offset ] ) ) ; }


	public function  offsetGet ( $offset )
	   {
		if  ( isset ( $this -> Map [ $offset ] ) )
			return ( mb_convert_encoding ( '&#' . sprintf ( '%d', $this -> Map [ $offset ] ) . ';', 'UTF-8', 'HTML-ENTITIES' ) ) ;
		else
			return ( chr ( $offset ) ) ;
	    }

	public function  offsetSet ( $offset, $value )
	   { throw ( new \RuntimeException ( "Unsupported operation." ) ) ; }

	public function  offsetUnset ( $offset )
	   { throw ( new \RuntimeException ( "Unsupported operation." ) ) ; }

    }